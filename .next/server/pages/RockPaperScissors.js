/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/RockPaperScissors";
exports.ids = ["pages/RockPaperScissors"];
exports.modules = {

/***/ "./src/styles/RockPaperScissors.module.css":
/*!*************************************************!*\
  !*** ./src/styles/RockPaperScissors.module.css ***!
  \*************************************************/
/***/ ((module) => {

eval("// Exports\nmodule.exports = {\n\t\"container\": \"RockPaperScissors_container__ki5_U\",\n\t\"moves\": \"RockPaperScissors_moves__Af7aN\",\n\t\"status\": \"RockPaperScissors_status__QOOAX\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGVzL1JvY2tQYXBlclNjaXNzb3JzLm1vZHVsZS5jc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdmF0ZV92b3RpbmdfY29kZXNwYWNlLy4vc3JjL3N0eWxlcy9Sb2NrUGFwZXJTY2lzc29ycy5tb2R1bGUuY3NzPzQ0OWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiY29udGFpbmVyXCI6IFwiUm9ja1BhcGVyU2Npc3NvcnNfY29udGFpbmVyX19raTVfVVwiLFxuXHRcIm1vdmVzXCI6IFwiUm9ja1BhcGVyU2Npc3NvcnNfbW92ZXNfX0FmN2FOXCIsXG5cdFwic3RhdHVzXCI6IFwiUm9ja1BhcGVyU2Npc3NvcnNfc3RhdHVzX19RT09BWFwiXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/styles/RockPaperScissors.module.css\n");

/***/ }),

/***/ "__barrel_optimize__?names=Button,Spin,notification!=!./node_modules/antd/es/index.js":
/*!********************************************************************************************!*\
  !*** __barrel_optimize__?names=Button,Spin,notification!=!./node_modules/antd/es/index.js ***!
  \********************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: () => (/* reexport safe */ _button__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   Spin: () => (/* reexport safe */ _spin__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   notification: () => (/* reexport safe */ _notification__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _button__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./button */ \"./node_modules/antd/es/button/index.js\");\n/* harmony import */ var _spin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./spin */ \"./node_modules/antd/es/spin/index.js\");\n/* harmony import */ var _notification__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./notification */ \"./node_modules/antd/es/notification/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_spin__WEBPACK_IMPORTED_MODULE_1__]);\n_spin__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\"use client\";\n\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX19iYXJyZWxfb3B0aW1pemVfXz9uYW1lcz1CdXR0b24sU3Bpbixub3RpZmljYXRpb24hPSEuL25vZGVfbW9kdWxlcy9hbnRkL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOztBQUU0QztBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdmF0ZV92b3RpbmdfY29kZXNwYWNlLy4vbm9kZV9tb2R1bGVzL2FudGQvZXMvaW5kZXguanM/N2QwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBCdXR0b24gfSBmcm9tIFwiLi9idXR0b25cIlxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTcGluIH0gZnJvbSBcIi4vc3BpblwiXG5leHBvcnQgeyBkZWZhdWx0IGFzIG5vdGlmaWNhdGlvbiB9IGZyb20gXCIuL25vdGlmaWNhdGlvblwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///__barrel_optimize__?names=Button,Spin,notification!=!./node_modules/antd/es/index.js\n");

/***/ }),

/***/ "__barrel_optimize__?names=FaHandPaper,FaHandRock,FaHandScissors!=!./node_modules/react-icons/fa/index.mjs":
/*!*****************************************************************************************************************!*\
  !*** __barrel_optimize__?names=FaHandPaper,FaHandRock,FaHandScissors!=!./node_modules/react-icons/fa/index.mjs ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _home_john_play_Documents_joaolago1113_ZKRPS_zkrps_node_modules_react_icons_fa_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/react-icons/fa/index.mjs */ "./node_modules/react-icons/fa/index.mjs");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _home_john_play_Documents_joaolago1113_ZKRPS_zkrps_node_modules_react_icons_fa_index_mjs__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _home_john_play_Documents_joaolago1113_ZKRPS_zkrps_node_modules_react_icons_fa_index_mjs__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2FRockPaperScissors&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2FRockPaperScissors.tsx&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2FRockPaperScissors&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2FRockPaperScissors.tsx&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getServerSideProps: () => (/* binding */ getServerSideProps),\n/* harmony export */   getStaticPaths: () => (/* binding */ getStaticPaths),\n/* harmony export */   getStaticProps: () => (/* binding */ getStaticProps),\n/* harmony export */   reportWebVitals: () => (/* binding */ reportWebVitals),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   unstable_getServerProps: () => (/* binding */ unstable_getServerProps),\n/* harmony export */   unstable_getServerSideProps: () => (/* binding */ unstable_getServerSideProps),\n/* harmony export */   unstable_getStaticParams: () => (/* binding */ unstable_getStaticParams),\n/* harmony export */   unstable_getStaticPaths: () => (/* binding */ unstable_getStaticPaths),\n/* harmony export */   unstable_getStaticProps: () => (/* binding */ unstable_getStaticProps)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages/module.compiled */ \"./node_modules/next/dist/server/future/route-modules/pages/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var private_next_pages_document__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! private-next-pages/_document */ \"./node_modules/next/dist/pages/_document.js\");\n/* harmony import */ var private_next_pages_document__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(private_next_pages_document__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var private_next_pages_app__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! private-next-pages/_app */ \"./node_modules/next/dist/pages/_app.js\");\n/* harmony import */ var private_next_pages_app__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(private_next_pages_app__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _src_pages_RockPaperScissors_tsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/pages/RockPaperScissors.tsx */ \"./src/pages/RockPaperScissors.tsx\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_src_pages_RockPaperScissors_tsx__WEBPACK_IMPORTED_MODULE_5__]);\n_src_pages_RockPaperScissors_tsx__WEBPACK_IMPORTED_MODULE_5__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the app and document modules.\n\n\n// Import the userland code.\n\n// Re-export the component (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_RockPaperScissors_tsx__WEBPACK_IMPORTED_MODULE_5__, \"default\"));\n// Re-export methods.\nconst getStaticProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_RockPaperScissors_tsx__WEBPACK_IMPORTED_MODULE_5__, \"getStaticProps\");\nconst getStaticPaths = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_RockPaperScissors_tsx__WEBPACK_IMPORTED_MODULE_5__, \"getStaticPaths\");\nconst getServerSideProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_RockPaperScissors_tsx__WEBPACK_IMPORTED_MODULE_5__, \"getServerSideProps\");\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_RockPaperScissors_tsx__WEBPACK_IMPORTED_MODULE_5__, \"config\");\nconst reportWebVitals = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_RockPaperScissors_tsx__WEBPACK_IMPORTED_MODULE_5__, \"reportWebVitals\");\n// Re-export legacy methods.\nconst unstable_getStaticProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_RockPaperScissors_tsx__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getStaticProps\");\nconst unstable_getStaticPaths = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_RockPaperScissors_tsx__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getStaticPaths\");\nconst unstable_getStaticParams = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_RockPaperScissors_tsx__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getStaticParams\");\nconst unstable_getServerProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_RockPaperScissors_tsx__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getServerProps\");\nconst unstable_getServerSideProps = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_RockPaperScissors_tsx__WEBPACK_IMPORTED_MODULE_5__, \"unstable_getServerSideProps\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES,\n        page: \"/RockPaperScissors\",\n        pathname: \"/RockPaperScissors\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    components: {\n        App: (private_next_pages_app__WEBPACK_IMPORTED_MODULE_4___default()),\n        Document: (private_next_pages_document__WEBPACK_IMPORTED_MODULE_3___default())\n    },\n    userland: _src_pages_RockPaperScissors_tsx__WEBPACK_IMPORTED_MODULE_5__\n});\n\n//# sourceMappingURL=pages.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTJnBhZ2U9JTJGUm9ja1BhcGVyU2Npc3NvcnMmcHJlZmVycmVkUmVnaW9uPSZhYnNvbHV0ZVBhZ2VQYXRoPS4lMkZzcmMlMkZwYWdlcyUyRlJvY2tQYXBlclNjaXNzb3JzLnRzeCZhYnNvbHV0ZUFwcFBhdGg9cHJpdmF0ZS1uZXh0LXBhZ2VzJTJGX2FwcCZhYnNvbHV0ZURvY3VtZW50UGF0aD1wcml2YXRlLW5leHQtcGFnZXMlMkZfZG9jdW1lbnQmbWlkZGxld2FyZUNvbmZpZ0Jhc2U2ND1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErRjtBQUNoQztBQUNMO0FBQzFEO0FBQ29EO0FBQ1Y7QUFDMUM7QUFDOEQ7QUFDOUQ7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLDZEQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLHVCQUF1Qix3RUFBSyxDQUFDLDZEQUFRO0FBQ3JDLHVCQUF1Qix3RUFBSyxDQUFDLDZEQUFRO0FBQ3JDLDJCQUEyQix3RUFBSyxDQUFDLDZEQUFRO0FBQ3pDLGVBQWUsd0VBQUssQ0FBQyw2REFBUTtBQUM3Qix3QkFBd0Isd0VBQUssQ0FBQyw2REFBUTtBQUM3QztBQUNPLGdDQUFnQyx3RUFBSyxDQUFDLDZEQUFRO0FBQzlDLGdDQUFnQyx3RUFBSyxDQUFDLDZEQUFRO0FBQzlDLGlDQUFpQyx3RUFBSyxDQUFDLDZEQUFRO0FBQy9DLGdDQUFnQyx3RUFBSyxDQUFDLDZEQUFRO0FBQzlDLG9DQUFvQyx3RUFBSyxDQUFDLDZEQUFRO0FBQ3pEO0FBQ08sd0JBQXdCLHlHQUFnQjtBQUMvQztBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFdBQVc7QUFDWCxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMLFlBQVk7QUFDWixDQUFDOztBQUVELGlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdmF0ZV92b3RpbmdfY29kZXNwYWNlLz9iYTU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhZ2VzUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9wYWdlcy9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgYXBwIGFuZCBkb2N1bWVudCBtb2R1bGVzLlxuaW1wb3J0IERvY3VtZW50IGZyb20gXCJwcml2YXRlLW5leHQtcGFnZXMvX2RvY3VtZW50XCI7XG5pbXBvcnQgQXBwIGZyb20gXCJwcml2YXRlLW5leHQtcGFnZXMvX2FwcFwiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vc3JjL3BhZ2VzL1JvY2tQYXBlclNjaXNzb3JzLnRzeFwiO1xuLy8gUmUtZXhwb3J0IHRoZSBjb21wb25lbnQgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsIFwiZGVmYXVsdFwiKTtcbi8vIFJlLWV4cG9ydCBtZXRob2RzLlxuZXhwb3J0IGNvbnN0IGdldFN0YXRpY1Byb3BzID0gaG9pc3QodXNlcmxhbmQsIFwiZ2V0U3RhdGljUHJvcHNcIik7XG5leHBvcnQgY29uc3QgZ2V0U3RhdGljUGF0aHMgPSBob2lzdCh1c2VybGFuZCwgXCJnZXRTdGF0aWNQYXRoc1wiKTtcbmV4cG9ydCBjb25zdCBnZXRTZXJ2ZXJTaWRlUHJvcHMgPSBob2lzdCh1c2VybGFuZCwgXCJnZXRTZXJ2ZXJTaWRlUHJvcHNcIik7XG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsIFwiY29uZmlnXCIpO1xuZXhwb3J0IGNvbnN0IHJlcG9ydFdlYlZpdGFscyA9IGhvaXN0KHVzZXJsYW5kLCBcInJlcG9ydFdlYlZpdGFsc1wiKTtcbi8vIFJlLWV4cG9ydCBsZWdhY3kgbWV0aG9kcy5cbmV4cG9ydCBjb25zdCB1bnN0YWJsZV9nZXRTdGF0aWNQcm9wcyA9IGhvaXN0KHVzZXJsYW5kLCBcInVuc3RhYmxlX2dldFN0YXRpY1Byb3BzXCIpO1xuZXhwb3J0IGNvbnN0IHVuc3RhYmxlX2dldFN0YXRpY1BhdGhzID0gaG9pc3QodXNlcmxhbmQsIFwidW5zdGFibGVfZ2V0U3RhdGljUGF0aHNcIik7XG5leHBvcnQgY29uc3QgdW5zdGFibGVfZ2V0U3RhdGljUGFyYW1zID0gaG9pc3QodXNlcmxhbmQsIFwidW5zdGFibGVfZ2V0U3RhdGljUGFyYW1zXCIpO1xuZXhwb3J0IGNvbnN0IHVuc3RhYmxlX2dldFNlcnZlclByb3BzID0gaG9pc3QodXNlcmxhbmQsIFwidW5zdGFibGVfZ2V0U2VydmVyUHJvcHNcIik7XG5leHBvcnQgY29uc3QgdW5zdGFibGVfZ2V0U2VydmVyU2lkZVByb3BzID0gaG9pc3QodXNlcmxhbmQsIFwidW5zdGFibGVfZ2V0U2VydmVyU2lkZVByb3BzXCIpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVMsXG4gICAgICAgIHBhZ2U6IFwiL1JvY2tQYXBlclNjaXNzb3JzXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9Sb2NrUGFwZXJTY2lzc29yc1wiLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZW4ndCB1c2VkIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcIlwiXG4gICAgfSxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEFwcCxcbiAgICAgICAgRG9jdW1lbnRcbiAgICB9LFxuICAgIHVzZXJsYW5kXG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2FRockPaperScissors&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2FRockPaperScissors.tsx&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "./src/artifacts/EasyPrivateVoting.ts":
/*!********************************************!*\
  !*** ./src/artifacts/EasyPrivateVoting.ts ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EasyPrivateVotingContract: () => (/* binding */ EasyPrivateVotingContract),\n/* harmony export */   EasyPrivateVotingContractArtifact: () => (/* binding */ EasyPrivateVotingContractArtifact)\n/* harmony export */ });\n/* harmony import */ var _aztec_aztec_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aztec/aztec.js */ \"@aztec/aztec.js\");\n/* harmony import */ var _target_easy_private_voting_contract_EasyPrivateVoting_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../target/easy_private_voting_contract-EasyPrivateVoting.json */ \"./target/easy_private_voting_contract-EasyPrivateVoting.json\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_aztec_aztec_js__WEBPACK_IMPORTED_MODULE_0__]);\n_aztec_aztec_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* Autogenerated file, do not edit! */ /* eslint-disable */ \n\nconst EasyPrivateVotingContractArtifact = (0,_aztec_aztec_js__WEBPACK_IMPORTED_MODULE_0__.loadContractArtifact)(_target_easy_private_voting_contract_EasyPrivateVoting_json__WEBPACK_IMPORTED_MODULE_1__);\n/**\n * Type-safe interface for contract EasyPrivateVoting;\n */ class EasyPrivateVotingContract extends _aztec_aztec_js__WEBPACK_IMPORTED_MODULE_0__.ContractBase {\n    constructor(instance, wallet){\n        super(instance, EasyPrivateVotingContractArtifact, wallet);\n    }\n    /**\n   * Creates a contract instance.\n   * @param address - The deployed contract's address.\n   * @param wallet - The wallet to use when interacting with the contract.\n   * @returns A promise that resolves to a new Contract instance.\n   */ static async at(address, wallet) {\n        return _aztec_aztec_js__WEBPACK_IMPORTED_MODULE_0__.Contract.at(address, EasyPrivateVotingContract.artifact, wallet);\n    }\n    /**\n   * Creates a tx to deploy a new instance of this contract.\n   */ static deploy(wallet, admin) {\n        return new _aztec_aztec_js__WEBPACK_IMPORTED_MODULE_0__.DeployMethod(_aztec_aztec_js__WEBPACK_IMPORTED_MODULE_0__.PublicKeys.default(), wallet, EasyPrivateVotingContractArtifact, EasyPrivateVotingContract.at, Array.from(arguments).slice(1));\n    }\n    /**\n   * Creates a tx to deploy a new instance of this contract using the specified public keys hash to derive the address.\n   */ static deployWithPublicKeys(publicKeys, wallet, admin) {\n        return new _aztec_aztec_js__WEBPACK_IMPORTED_MODULE_0__.DeployMethod(publicKeys, wallet, EasyPrivateVotingContractArtifact, EasyPrivateVotingContract.at, Array.from(arguments).slice(2));\n    }\n    /**\n   * Creates a tx to deploy a new instance of this contract using the specified constructor method.\n   */ static deployWithOpts(opts, ...args) {\n        return new _aztec_aztec_js__WEBPACK_IMPORTED_MODULE_0__.DeployMethod(opts.publicKeys ?? _aztec_aztec_js__WEBPACK_IMPORTED_MODULE_0__.PublicKeys.default(), opts.wallet, EasyPrivateVotingContractArtifact, EasyPrivateVotingContract.at, Array.from(arguments).slice(1), opts.method ?? \"constructor\");\n    }\n    /**\n   * Returns this contract's artifact.\n   */ static get artifact() {\n        return EasyPrivateVotingContractArtifact;\n    }\n    static get storage() {\n        return {\n            admin: {\n                slot: new _aztec_aztec_js__WEBPACK_IMPORTED_MODULE_0__.Fr(1n)\n            },\n            tally: {\n                slot: new _aztec_aztec_js__WEBPACK_IMPORTED_MODULE_0__.Fr(2n)\n            },\n            vote_ended: {\n                slot: new _aztec_aztec_js__WEBPACK_IMPORTED_MODULE_0__.Fr(3n)\n            },\n            active_at_block: {\n                slot: new _aztec_aztec_js__WEBPACK_IMPORTED_MODULE_0__.Fr(4n)\n            }\n        };\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXJ0aWZhY3RzL0Vhc3lQcml2YXRlVm90aW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDQSxvQ0FBb0MsR0FFcEMsa0JBQWtCLEdBZ0NPO0FBQ29IO0FBQ3RJLE1BQU1RLG9DQUFvQ0oscUVBQW9CQSxDQUFDRSx3RkFBcUNBLEVBQTBCO0FBSXJJOztDQUVDLEdBQ00sTUFBTUcsa0NBQWtDUix5REFBWUE7SUFFekQsWUFDRVMsUUFBcUMsRUFDckNDLE1BQWMsQ0FDZDtRQUNBLEtBQUssQ0FBQ0QsVUFBVUYsbUNBQW1DRztJQUNyRDtJQUlBOzs7OztHQUtDLEdBQ0QsYUFBb0JDLEdBQ2xCQyxPQUFxQixFQUNyQkYsTUFBYyxFQUNkO1FBQ0EsT0FBT1gscURBQVFBLENBQUNZLEVBQUUsQ0FBQ0MsU0FBU0osMEJBQTBCSyxRQUFRLEVBQUVIO0lBQ2xFO0lBR0E7O0dBRUMsR0FDRCxPQUFjSSxPQUFPSixNQUFjLEVBQUVLLEtBQXVCLEVBQUU7UUFDNUQsT0FBTyxJQUFJZCx5REFBWUEsQ0FBNEJHLHVEQUFVQSxDQUFDWSxPQUFPLElBQUlOLFFBQVFILG1DQUFtQ0MsMEJBQTBCRyxFQUFFLEVBQUVNLE1BQU1DLElBQUksQ0FBQ0MsV0FBV0MsS0FBSyxDQUFDO0lBQ2hMO0lBRUE7O0dBRUMsR0FDRCxPQUFjQyxxQkFBcUJDLFVBQXNCLEVBQUVaLE1BQWMsRUFBRUssS0FBdUIsRUFBRTtRQUNsRyxPQUFPLElBQUlkLHlEQUFZQSxDQUE0QnFCLFlBQVlaLFFBQVFILG1DQUFtQ0MsMEJBQTBCRyxFQUFFLEVBQUVNLE1BQU1DLElBQUksQ0FBQ0MsV0FBV0MsS0FBSyxDQUFDO0lBQ3RLO0lBRUE7O0dBRUMsR0FDRCxPQUFjRyxlQUNaQyxJQUE2RCxFQUM3RCxHQUFHQyxJQUF5RCxFQUM1RDtRQUNBLE9BQU8sSUFBSXhCLHlEQUFZQSxDQUNyQnVCLEtBQUtGLFVBQVUsSUFBSWxCLHVEQUFVQSxDQUFDWSxPQUFPLElBQ3JDUSxLQUFLZCxNQUFNLEVBQ1hILG1DQUNBQywwQkFBMEJHLEVBQUUsRUFDNUJNLE1BQU1DLElBQUksQ0FBQ0MsV0FBV0MsS0FBSyxDQUFDLElBQzVCSSxLQUFLRSxNQUFNLElBQUk7SUFFbkI7SUFJQTs7R0FFQyxHQUNELFdBQWtCYixXQUE2QjtRQUM3QyxPQUFPTjtJQUNUO0lBR0EsV0FBa0JvQixVQUF1RjtRQUNyRyxPQUFPO1lBQ0xaLE9BQU87Z0JBQ1RhLE1BQU0sSUFBSTFCLCtDQUFFQSxDQUFDLEVBQUU7WUFDakI7WUFDSjJCLE9BQU87Z0JBQ0RELE1BQU0sSUFBSTFCLCtDQUFFQSxDQUFDLEVBQUU7WUFDakI7WUFDSjRCLFlBQVk7Z0JBQ05GLE1BQU0sSUFBSTFCLCtDQUFFQSxDQUFDLEVBQUU7WUFDakI7WUFDSjZCLGlCQUFpQjtnQkFDWEgsTUFBTSxJQUFJMUIsK0NBQUVBLENBQUMsRUFBRTtZQUNqQjtRQUNFO0lBQ0Y7QUErQkoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml2YXRlX3ZvdGluZ19jb2Rlc3BhY2UvLi9zcmMvYXJ0aWZhY3RzL0Vhc3lQcml2YXRlVm90aW5nLnRzPzQ4NmQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiBBdXRvZ2VuZXJhdGVkIGZpbGUsIGRvIG5vdCBlZGl0ISAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHtcbiAgdHlwZSBBYmlUeXBlLFxuICBBenRlY0FkZHJlc3MsXG4gIHR5cGUgQXp0ZWNBZGRyZXNzTGlrZSxcbiAgQ29tcGxldGVBZGRyZXNzLFxuICBDb250cmFjdCxcbiAgdHlwZSBDb250cmFjdEFydGlmYWN0LFxuICBDb250cmFjdEJhc2UsXG4gIENvbnRyYWN0RnVuY3Rpb25JbnRlcmFjdGlvbixcbiAgdHlwZSBDb250cmFjdEluc3RhbmNlV2l0aEFkZHJlc3MsXG4gIHR5cGUgQ29udHJhY3RNZXRob2QsXG4gIHR5cGUgQ29udHJhY3RTdG9yYWdlTGF5b3V0LFxuICB0eXBlIENvbnRyYWN0Tm90ZXMsXG4gIGRlY29kZUZyb21BYmksXG4gIERlcGxveU1ldGhvZCxcbiAgRXRoQWRkcmVzcyxcbiAgdHlwZSBFdGhBZGRyZXNzTGlrZSxcbiAgRXZlbnRTZWxlY3RvcixcbiAgdHlwZSBGaWVsZExpa2UsXG4gIEZyLFxuICB0eXBlIEZ1bmN0aW9uU2VsZWN0b3JMaWtlLFxuICBMMUV2ZW50UGF5bG9hZCxcbiAgbG9hZENvbnRyYWN0QXJ0aWZhY3QsXG4gIHR5cGUgTm9pckNvbXBpbGVkQ29udHJhY3QsXG4gIE5vdGVTZWxlY3RvcixcbiAgUG9pbnQsXG4gIHR5cGUgUHVibGljS2V5LFxuICBQdWJsaWNLZXlzLFxuICB0eXBlIFVuZW5jcnlwdGVkTDJMb2csXG4gIHR5cGUgV2FsbGV0LFxuICB0eXBlIFdyYXBwZWRGaWVsZExpa2UsXG59IGZyb20gJ0BhenRlYy9henRlYy5qcyc7XG5pbXBvcnQgRWFzeVByaXZhdGVWb3RpbmdDb250cmFjdEFydGlmYWN0SnNvbiBmcm9tICcuLi8uLi90YXJnZXQvZWFzeV9wcml2YXRlX3ZvdGluZ19jb250cmFjdC1FYXN5UHJpdmF0ZVZvdGluZy5qc29uJyBhc3NlcnQgeyB0eXBlOiAnanNvbicgfTtcbmV4cG9ydCBjb25zdCBFYXN5UHJpdmF0ZVZvdGluZ0NvbnRyYWN0QXJ0aWZhY3QgPSBsb2FkQ29udHJhY3RBcnRpZmFjdChFYXN5UHJpdmF0ZVZvdGluZ0NvbnRyYWN0QXJ0aWZhY3RKc29uIGFzIE5vaXJDb21waWxlZENvbnRyYWN0KTtcblxuXG5cbi8qKlxuICogVHlwZS1zYWZlIGludGVyZmFjZSBmb3IgY29udHJhY3QgRWFzeVByaXZhdGVWb3Rpbmc7XG4gKi9cbmV4cG9ydCBjbGFzcyBFYXN5UHJpdmF0ZVZvdGluZ0NvbnRyYWN0IGV4dGVuZHMgQ29udHJhY3RCYXNlIHtcbiAgXG4gIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgaW5zdGFuY2U6IENvbnRyYWN0SW5zdGFuY2VXaXRoQWRkcmVzcyxcbiAgICB3YWxsZXQ6IFdhbGxldCxcbiAgKSB7XG4gICAgc3VwZXIoaW5zdGFuY2UsIEVhc3lQcml2YXRlVm90aW5nQ29udHJhY3RBcnRpZmFjdCwgd2FsbGV0KTtcbiAgfVxuICBcblxuICBcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb250cmFjdCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIGFkZHJlc3MgLSBUaGUgZGVwbG95ZWQgY29udHJhY3QncyBhZGRyZXNzLlxuICAgKiBAcGFyYW0gd2FsbGV0IC0gVGhlIHdhbGxldCB0byB1c2Ugd2hlbiBpbnRlcmFjdGluZyB3aXRoIHRoZSBjb250cmFjdC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBuZXcgQ29udHJhY3QgaW5zdGFuY2UuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIGF0KFxuICAgIGFkZHJlc3M6IEF6dGVjQWRkcmVzcyxcbiAgICB3YWxsZXQ6IFdhbGxldCxcbiAgKSB7XG4gICAgcmV0dXJuIENvbnRyYWN0LmF0KGFkZHJlc3MsIEVhc3lQcml2YXRlVm90aW5nQ29udHJhY3QuYXJ0aWZhY3QsIHdhbGxldCkgYXMgUHJvbWlzZTxFYXN5UHJpdmF0ZVZvdGluZ0NvbnRyYWN0PjtcbiAgfVxuXG4gIFxuICAvKipcbiAgICogQ3JlYXRlcyBhIHR4IHRvIGRlcGxveSBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIGNvbnRyYWN0LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBkZXBsb3kod2FsbGV0OiBXYWxsZXQsIGFkbWluOiBBenRlY0FkZHJlc3NMaWtlKSB7XG4gICAgcmV0dXJuIG5ldyBEZXBsb3lNZXRob2Q8RWFzeVByaXZhdGVWb3RpbmdDb250cmFjdD4oUHVibGljS2V5cy5kZWZhdWx0KCksIHdhbGxldCwgRWFzeVByaXZhdGVWb3RpbmdDb250cmFjdEFydGlmYWN0LCBFYXN5UHJpdmF0ZVZvdGluZ0NvbnRyYWN0LmF0LCBBcnJheS5mcm9tKGFyZ3VtZW50cykuc2xpY2UoMSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0eCB0byBkZXBsb3kgYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBjb250cmFjdCB1c2luZyB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXlzIGhhc2ggdG8gZGVyaXZlIHRoZSBhZGRyZXNzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBkZXBsb3lXaXRoUHVibGljS2V5cyhwdWJsaWNLZXlzOiBQdWJsaWNLZXlzLCB3YWxsZXQ6IFdhbGxldCwgYWRtaW46IEF6dGVjQWRkcmVzc0xpa2UpIHtcbiAgICByZXR1cm4gbmV3IERlcGxveU1ldGhvZDxFYXN5UHJpdmF0ZVZvdGluZ0NvbnRyYWN0PihwdWJsaWNLZXlzLCB3YWxsZXQsIEVhc3lQcml2YXRlVm90aW5nQ29udHJhY3RBcnRpZmFjdCwgRWFzeVByaXZhdGVWb3RpbmdDb250cmFjdC5hdCwgQXJyYXkuZnJvbShhcmd1bWVudHMpLnNsaWNlKDIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdHggdG8gZGVwbG95IGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgY29udHJhY3QgdXNpbmcgdGhlIHNwZWNpZmllZCBjb25zdHJ1Y3RvciBtZXRob2QuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGRlcGxveVdpdGhPcHRzPE0gZXh0ZW5kcyBrZXlvZiBFYXN5UHJpdmF0ZVZvdGluZ0NvbnRyYWN0WydtZXRob2RzJ10+KFxuICAgIG9wdHM6IHsgcHVibGljS2V5cz86IFB1YmxpY0tleXM7IG1ldGhvZD86IE07IHdhbGxldDogV2FsbGV0IH0sXG4gICAgLi4uYXJnczogUGFyYW1ldGVyczxFYXN5UHJpdmF0ZVZvdGluZ0NvbnRyYWN0WydtZXRob2RzJ11bTV0+XG4gICkge1xuICAgIHJldHVybiBuZXcgRGVwbG95TWV0aG9kPEVhc3lQcml2YXRlVm90aW5nQ29udHJhY3Q+KFxuICAgICAgb3B0cy5wdWJsaWNLZXlzID8/IFB1YmxpY0tleXMuZGVmYXVsdCgpLFxuICAgICAgb3B0cy53YWxsZXQsXG4gICAgICBFYXN5UHJpdmF0ZVZvdGluZ0NvbnRyYWN0QXJ0aWZhY3QsXG4gICAgICBFYXN5UHJpdmF0ZVZvdGluZ0NvbnRyYWN0LmF0LFxuICAgICAgQXJyYXkuZnJvbShhcmd1bWVudHMpLnNsaWNlKDEpLFxuICAgICAgb3B0cy5tZXRob2QgPz8gJ2NvbnN0cnVjdG9yJyxcbiAgICApO1xuICB9XG4gIFxuXG4gIFxuICAvKipcbiAgICogUmV0dXJucyB0aGlzIGNvbnRyYWN0J3MgYXJ0aWZhY3QuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldCBhcnRpZmFjdCgpOiBDb250cmFjdEFydGlmYWN0IHtcbiAgICByZXR1cm4gRWFzeVByaXZhdGVWb3RpbmdDb250cmFjdEFydGlmYWN0O1xuICB9XG4gIFxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0IHN0b3JhZ2UoKTogQ29udHJhY3RTdG9yYWdlTGF5b3V0PCdhZG1pbicgfCAndGFsbHknIHwgJ3ZvdGVfZW5kZWQnIHwgJ2FjdGl2ZV9hdF9ibG9jayc+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkbWluOiB7XG4gICAgICBzbG90OiBuZXcgRnIoMW4pLFxuICAgIH0sXG50YWxseToge1xuICAgICAgc2xvdDogbmV3IEZyKDJuKSxcbiAgICB9LFxudm90ZV9lbmRlZDoge1xuICAgICAgc2xvdDogbmV3IEZyKDNuKSxcbiAgICB9LFxuYWN0aXZlX2F0X2Jsb2NrOiB7XG4gICAgICBzbG90OiBuZXcgRnIoNG4pLFxuICAgIH1cbiAgICAgIH0gYXMgQ29udHJhY3RTdG9yYWdlTGF5b3V0PCdhZG1pbicgfCAndGFsbHknIHwgJ3ZvdGVfZW5kZWQnIHwgJ2FjdGl2ZV9hdF9ibG9jayc+O1xuICAgIH1cbiAgICBcblxuICBcblxuICAvKiogVHlwZS1zYWZlIHdyYXBwZXJzIGZvciB0aGUgcHVibGljIG1ldGhvZHMgZXhwb3NlZCBieSB0aGUgY29udHJhY3QuICovXG4gIHB1YmxpYyBkZWNsYXJlIG1ldGhvZHM6IHtcbiAgICBcbiAgICAvKiogY2FzdF92b3RlKGNhbmRpZGF0ZTogZmllbGQpICovXG4gICAgY2FzdF92b3RlOiAoKGNhbmRpZGF0ZTogRmllbGRMaWtlKSA9PiBDb250cmFjdEZ1bmN0aW9uSW50ZXJhY3Rpb24pICYgUGljazxDb250cmFjdE1ldGhvZCwgJ3NlbGVjdG9yJz47XG5cbiAgICAvKiogY29tcHV0ZV9ub3RlX2hhc2hfYW5kX29wdGlvbmFsbHlfYV9udWxsaWZpZXIoY29udHJhY3RfYWRkcmVzczogc3RydWN0LCBub25jZTogZmllbGQsIHN0b3JhZ2Vfc2xvdDogZmllbGQsIG5vdGVfdHlwZV9pZDogZmllbGQsIGNvbXB1dGVfbnVsbGlmaWVyOiBib29sZWFuLCBzZXJpYWxpemVkX25vdGU6IGFycmF5KSAqL1xuICAgIGNvbXB1dGVfbm90ZV9oYXNoX2FuZF9vcHRpb25hbGx5X2FfbnVsbGlmaWVyOiAoKGNvbnRyYWN0X2FkZHJlc3M6IEF6dGVjQWRkcmVzc0xpa2UsIG5vbmNlOiBGaWVsZExpa2UsIHN0b3JhZ2Vfc2xvdDogRmllbGRMaWtlLCBub3RlX3R5cGVfaWQ6IEZpZWxkTGlrZSwgY29tcHV0ZV9udWxsaWZpZXI6IGJvb2xlYW4sIHNlcmlhbGl6ZWRfbm90ZTogRmllbGRMaWtlW10pID0+IENvbnRyYWN0RnVuY3Rpb25JbnRlcmFjdGlvbikgJiBQaWNrPENvbnRyYWN0TWV0aG9kLCAnc2VsZWN0b3InPjtcblxuICAgIC8qKiBjb25zdHJ1Y3RvcihhZG1pbjogc3RydWN0KSAqL1xuICAgIGNvbnN0cnVjdG9yOiAoKGFkbWluOiBBenRlY0FkZHJlc3NMaWtlKSA9PiBDb250cmFjdEZ1bmN0aW9uSW50ZXJhY3Rpb24pICYgUGljazxDb250cmFjdE1ldGhvZCwgJ3NlbGVjdG9yJz47XG5cbiAgICAvKiogZW5kX3ZvdGUoKSAqL1xuICAgIGVuZF92b3RlOiAoKCkgPT4gQ29udHJhY3RGdW5jdGlvbkludGVyYWN0aW9uKSAmIFBpY2s8Q29udHJhY3RNZXRob2QsICdzZWxlY3Rvcic+O1xuXG4gICAgLyoqIGdldF92b3RlKGNhbmRpZGF0ZTogZmllbGQpICovXG4gICAgZ2V0X3ZvdGU6ICgoY2FuZGlkYXRlOiBGaWVsZExpa2UpID0+IENvbnRyYWN0RnVuY3Rpb25JbnRlcmFjdGlvbikgJiBQaWNrPENvbnRyYWN0TWV0aG9kLCAnc2VsZWN0b3InPjtcblxuICAgIC8qKiBwdWJsaWNfZGlzcGF0Y2goc2VsZWN0b3I6IGZpZWxkKSAqL1xuICAgIHB1YmxpY19kaXNwYXRjaDogKChzZWxlY3RvcjogRmllbGRMaWtlKSA9PiBDb250cmFjdEZ1bmN0aW9uSW50ZXJhY3Rpb24pICYgUGljazxDb250cmFjdE1ldGhvZCwgJ3NlbGVjdG9yJz47XG5cbiAgICAvKiogc3luY19ub3RlcygpICovXG4gICAgc3luY19ub3RlczogKCgpID0+IENvbnRyYWN0RnVuY3Rpb25JbnRlcmFjdGlvbikgJiBQaWNrPENvbnRyYWN0TWV0aG9kLCAnc2VsZWN0b3InPjtcbiAgfTtcblxuICBcbn1cbiJdLCJuYW1lcyI6WyJDb250cmFjdCIsIkNvbnRyYWN0QmFzZSIsIkRlcGxveU1ldGhvZCIsIkZyIiwibG9hZENvbnRyYWN0QXJ0aWZhY3QiLCJQdWJsaWNLZXlzIiwiRWFzeVByaXZhdGVWb3RpbmdDb250cmFjdEFydGlmYWN0SnNvbiIsInR5cGUiLCJFYXN5UHJpdmF0ZVZvdGluZ0NvbnRyYWN0QXJ0aWZhY3QiLCJFYXN5UHJpdmF0ZVZvdGluZ0NvbnRyYWN0IiwiaW5zdGFuY2UiLCJ3YWxsZXQiLCJhdCIsImFkZHJlc3MiLCJhcnRpZmFjdCIsImRlcGxveSIsImFkbWluIiwiZGVmYXVsdCIsIkFycmF5IiwiZnJvbSIsImFyZ3VtZW50cyIsInNsaWNlIiwiZGVwbG95V2l0aFB1YmxpY0tleXMiLCJwdWJsaWNLZXlzIiwiZGVwbG95V2l0aE9wdHMiLCJvcHRzIiwiYXJncyIsIm1ldGhvZCIsInN0b3JhZ2UiLCJzbG90IiwidGFsbHkiLCJ2b3RlX2VuZGVkIiwiYWN0aXZlX2F0X2Jsb2NrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/artifacts/EasyPrivateVoting.ts\n");

/***/ }),

/***/ "./src/components/Icons.tsx":
/*!**********************************!*\
  !*** ./src/components/Icons.tsx ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PaperIcon: () => (/* binding */ PaperIcon),\n/* harmony export */   RockIcon: () => (/* binding */ RockIcon),\n/* harmony export */   ScissorsIcon: () => (/* binding */ ScissorsIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _barrel_optimize_names_FaHandPaper_FaHandRock_FaHandScissors_react_icons_fa__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=FaHandPaper,FaHandRock,FaHandScissors!=!react-icons/fa */ \"__barrel_optimize__?names=FaHandPaper,FaHandRock,FaHandScissors!=!./node_modules/react-icons/fa/index.mjs\");\n\n\nconst RockIcon = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_FaHandPaper_FaHandRock_FaHandScissors_react_icons_fa__WEBPACK_IMPORTED_MODULE_1__.FaHandRock, {\n        size: 24\n    }, void 0, false, {\n        fileName: \"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/components/Icons.tsx\",\n        lineNumber: 3,\n        columnNumber: 31\n    }, undefined);\nconst PaperIcon = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_FaHandPaper_FaHandRock_FaHandScissors_react_icons_fa__WEBPACK_IMPORTED_MODULE_1__.FaHandPaper, {\n        size: 24\n    }, void 0, false, {\n        fileName: \"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/components/Icons.tsx\",\n        lineNumber: 4,\n        columnNumber: 32\n    }, undefined);\nconst ScissorsIcon = ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_FaHandPaper_FaHandRock_FaHandScissors_react_icons_fa__WEBPACK_IMPORTED_MODULE_1__.FaHandScissors, {\n        size: 24\n    }, void 0, false, {\n        fileName: \"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/components/Icons.tsx\",\n        lineNumber: 5,\n        columnNumber: 35\n    }, undefined);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9JY29ucy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF5RTtBQUVsRSxNQUFNRyxXQUFXLGtCQUFNLDhEQUFDSCxtSEFBVUE7UUFBQ0ksTUFBTTs7Ozs7a0JBQU87QUFDaEQsTUFBTUMsWUFBWSxrQkFBTSw4REFBQ0osb0hBQVdBO1FBQUNHLE1BQU07Ozs7O2tCQUFPO0FBQ2xELE1BQU1FLGVBQWUsa0JBQU0sOERBQUNKLHVIQUFjQTtRQUFDRSxNQUFNOzs7OztrQkFBTyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXZhdGVfdm90aW5nX2NvZGVzcGFjZS8uL3NyYy9jb21wb25lbnRzL0ljb25zLnRzeD84YTE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZhSGFuZFJvY2ssIEZhSGFuZFBhcGVyLCBGYUhhbmRTY2lzc29ycyB9IGZyb20gJ3JlYWN0LWljb25zL2ZhJztcblxuZXhwb3J0IGNvbnN0IFJvY2tJY29uID0gKCkgPT4gPEZhSGFuZFJvY2sgc2l6ZT17MjR9IC8+O1xuZXhwb3J0IGNvbnN0IFBhcGVySWNvbiA9ICgpID0+IDxGYUhhbmRQYXBlciBzaXplPXsyNH0gLz47XG5leHBvcnQgY29uc3QgU2Npc3NvcnNJY29uID0gKCkgPT4gPEZhSGFuZFNjaXNzb3JzIHNpemU9ezI0fSAvPjsgIl0sIm5hbWVzIjpbIkZhSGFuZFJvY2siLCJGYUhhbmRQYXBlciIsIkZhSGFuZFNjaXNzb3JzIiwiUm9ja0ljb24iLCJzaXplIiwiUGFwZXJJY29uIiwiU2Npc3NvcnNJY29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/Icons.tsx\n");

/***/ }),

/***/ "./src/pages/RockPaperScissors.tsx":
/*!*****************************************!*\
  !*** ./src/pages/RockPaperScissors.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _artifacts_EasyPrivateVoting__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../artifacts/EasyPrivateVoting */ \"./src/artifacts/EasyPrivateVoting.ts\");\n/* harmony import */ var _aztec_aztec_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @aztec/aztec.js */ \"@aztec/aztec.js\");\n/* harmony import */ var _aztec_accounts_testing__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @aztec/accounts/testing */ \"@aztec/accounts/testing\");\n/* harmony import */ var _aztec_circuits_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @aztec/circuits.js */ \"@aztec/circuits.js\");\n/* harmony import */ var _barrel_optimize_names_Button_Spin_notification_antd__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=Button,Spin,notification!=!antd */ \"__barrel_optimize__?names=Button,Spin,notification!=!./node_modules/antd/es/index.js\");\n/* harmony import */ var _components_Icons__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/Icons */ \"./src/components/Icons.tsx\");\n/* harmony import */ var _styles_RockPaperScissors_module_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../styles/RockPaperScissors.module.css */ \"./src/styles/RockPaperScissors.module.css\");\n/* harmony import */ var _styles_RockPaperScissors_module_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_styles_RockPaperScissors_module_css__WEBPACK_IMPORTED_MODULE_7__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_artifacts_EasyPrivateVoting__WEBPACK_IMPORTED_MODULE_2__, _aztec_aztec_js__WEBPACK_IMPORTED_MODULE_3__, _aztec_accounts_testing__WEBPACK_IMPORTED_MODULE_4__, _aztec_circuits_js__WEBPACK_IMPORTED_MODULE_5__, _barrel_optimize_names_Button_Spin_notification_antd__WEBPACK_IMPORTED_MODULE_8__]);\n([_artifacts_EasyPrivateVoting__WEBPACK_IMPORTED_MODULE_2__, _aztec_aztec_js__WEBPACK_IMPORTED_MODULE_3__, _aztec_accounts_testing__WEBPACK_IMPORTED_MODULE_4__, _aztec_circuits_js__WEBPACK_IMPORTED_MODULE_5__, _barrel_optimize_names_Button_Spin_notification_antd__WEBPACK_IMPORTED_MODULE_8__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n\nconst RockPaperScissors = ()=>{\n    const [pxe, setPxe] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [wallet, setWallet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [contract, setContract] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [selectedMove, setSelectedMove] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [gameStatus, setGameStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const initialize = async ()=>{\n            const { PXE_URL = \"http://localhost:8080\" } = process.env;\n            const pxeClient = await (0,_aztec_aztec_js__WEBPACK_IMPORTED_MODULE_3__.createPXEClient)(PXE_URL);\n            await (0,_aztec_aztec_js__WEBPACK_IMPORTED_MODULE_3__.waitForPXE)(pxeClient);\n            setPxe(pxeClient);\n            // Initialize wallet and contract\n            const [walletInstance] = await (0,_aztec_accounts_testing__WEBPACK_IMPORTED_MODULE_4__.getInitialTestAccountsWallets)(pxeClient);\n            setWallet(walletInstance);\n            const deployedContract = await _artifacts_EasyPrivateVoting__WEBPACK_IMPORTED_MODULE_2__.EasyPrivateVotingContract.at(_aztec_aztec_js__WEBPACK_IMPORTED_MODULE_3__.AztecAddress.fromString(\"0xYourContractAddress\"), walletInstance);\n            setContract(deployedContract);\n        };\n        initialize();\n    }, []);\n    const handleMoveSelection = (move)=>{\n        setSelectedMove(move);\n    };\n    const playMove = async ()=>{\n        if (!contract || !selectedMove) {\n            _barrel_optimize_names_Button_Spin_notification_antd__WEBPACK_IMPORTED_MODULE_8__.notification.error({\n                message: \"Please select a move.\"\n            });\n            return;\n        }\n        setLoading(true);\n        setGameStatus(\"Submitting your move...\");\n        try {\n            // Convert move to Field (assuming Rock=0, Paper=1, Scissors=2)\n            const moveValue = selectedMove === \"Rock\" ? 0 : selectedMove === \"Paper\" ? 1 : 2;\n            const fieldMove = new _aztec_circuits_js__WEBPACK_IMPORTED_MODULE_5__.Fr(moveValue);\n            const tx = await contract.methods.cast_vote(fieldMove).send().wait();\n            setGameStatus(\"Move submitted! Waiting for opponent...\");\n        // Fetch and display game result\n        // Replace with actual game result fetching logic\n        // For example:\n        // const result = await contract.methods.get_game_result().simulate();\n        // setGameStatus(`Game Result: ${result}`);\n        } catch (error) {\n            console.error(error);\n            setGameStatus(\"An error occurred while submitting your move.\");\n            _barrel_optimize_names_Button_Spin_notification_antd__WEBPACK_IMPORTED_MODULE_8__.notification.error({\n                message: \"Error\",\n                description: error.message\n            });\n        } finally{\n            setLoading(false);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_RockPaperScissors_module_css__WEBPACK_IMPORTED_MODULE_7___default().container),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                children: \"Rock Paper Scissors\"\n            }, void 0, false, {\n                fileName: \"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/pages/RockPaperScissors.tsx\",\n                lineNumber: 78,\n                columnNumber: 13\n            }, undefined),\n            !wallet ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Button_Spin_notification_antd__WEBPACK_IMPORTED_MODULE_8__.Button, {\n                type: \"primary\",\n                onClick: ()=>{},\n                children: \"Connect Wallet\"\n            }, void 0, false, {\n                fileName: \"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/pages/RockPaperScissors.tsx\",\n                lineNumber: 80,\n                columnNumber: 17\n            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_RockPaperScissors_module_css__WEBPACK_IMPORTED_MODULE_7___default().moves),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Button_Spin_notification_antd__WEBPACK_IMPORTED_MODULE_8__.Button, {\n                                icon: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icons__WEBPACK_IMPORTED_MODULE_6__.RockIcon, {}, void 0, false, {\n                                    fileName: \"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/pages/RockPaperScissors.tsx\",\n                                    lineNumber: 86,\n                                    columnNumber: 39\n                                }, void 0),\n                                onClick: ()=>handleMoveSelection(\"Rock\"),\n                                children: \"Rock\"\n                            }, void 0, false, {\n                                fileName: \"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/pages/RockPaperScissors.tsx\",\n                                lineNumber: 86,\n                                columnNumber: 25\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Button_Spin_notification_antd__WEBPACK_IMPORTED_MODULE_8__.Button, {\n                                icon: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icons__WEBPACK_IMPORTED_MODULE_6__.PaperIcon, {}, void 0, false, {\n                                    fileName: \"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/pages/RockPaperScissors.tsx\",\n                                    lineNumber: 89,\n                                    columnNumber: 39\n                                }, void 0),\n                                onClick: ()=>handleMoveSelection(\"Paper\"),\n                                children: \"Paper\"\n                            }, void 0, false, {\n                                fileName: \"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/pages/RockPaperScissors.tsx\",\n                                lineNumber: 89,\n                                columnNumber: 25\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Button_Spin_notification_antd__WEBPACK_IMPORTED_MODULE_8__.Button, {\n                                icon: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icons__WEBPACK_IMPORTED_MODULE_6__.ScissorsIcon, {}, void 0, false, {\n                                    fileName: \"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/pages/RockPaperScissors.tsx\",\n                                    lineNumber: 92,\n                                    columnNumber: 39\n                                }, void 0),\n                                onClick: ()=>handleMoveSelection(\"Scissors\"),\n                                children: \"Scissors\"\n                            }, void 0, false, {\n                                fileName: \"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/pages/RockPaperScissors.tsx\",\n                                lineNumber: 92,\n                                columnNumber: 25\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/pages/RockPaperScissors.tsx\",\n                        lineNumber: 85,\n                        columnNumber: 21\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Button_Spin_notification_antd__WEBPACK_IMPORTED_MODULE_8__.Button, {\n                        type: \"primary\",\n                        onClick: playMove,\n                        disabled: !selectedMove || loading,\n                        children: loading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Button_Spin_notification_antd__WEBPACK_IMPORTED_MODULE_8__.Spin, {}, void 0, false, {\n                            fileName: \"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/pages/RockPaperScissors.tsx\",\n                            lineNumber: 97,\n                            columnNumber: 36\n                        }, undefined) : \"Play\"\n                    }, void 0, false, {\n                        fileName: \"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/pages/RockPaperScissors.tsx\",\n                        lineNumber: 96,\n                        columnNumber: 21\n                    }, undefined),\n                    gameStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: (_styles_RockPaperScissors_module_css__WEBPACK_IMPORTED_MODULE_7___default().status),\n                        children: gameStatus\n                    }, void 0, false, {\n                        fileName: \"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/pages/RockPaperScissors.tsx\",\n                        lineNumber: 99,\n                        columnNumber: 36\n                    }, undefined)\n                ]\n            }, void 0, true)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/pages/RockPaperScissors.tsx\",\n        lineNumber: 77,\n        columnNumber: 9\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RockPaperScissors);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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a0Qsb0JBQU0sOERBQUM3QywyREFBWUE7Ozs7O2dDQUFLMkMsU0FBUyxJQUFNbkIsb0JBQW9COzBDQUFhOzs7Ozs7Ozs7Ozs7a0NBSXBGLDhEQUFDN0Isd0ZBQU1BO3dCQUFDK0MsTUFBSzt3QkFBVUMsU0FBU2pCO3dCQUFVb0IsVUFBVSxDQUFDckMsZ0JBQWdCSTtrQ0FDaEVBLHdCQUFVLDhEQUFDakIsc0ZBQUlBOzs7O3dDQUFNOzs7Ozs7b0JBRXpCZSw0QkFBYyw4REFBQ29DO3dCQUFFUixXQUFXdEMsb0ZBQWE7a0NBQUdVOzs7Ozs7Ozs7Ozs7OztBQUtqRTtBQUVBLGlFQUFlVCxpQkFBaUJBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml2YXRlX3ZvdGluZ19jb2Rlc3BhY2UvLi9zcmMvcGFnZXMvUm9ja1BhcGVyU2Npc3NvcnMudHN4Pzg3YjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVhc3lQcml2YXRlVm90aW5nQ29udHJhY3QgfSBmcm9tICcuLi9hcnRpZmFjdHMvRWFzeVByaXZhdGVWb3RpbmcnO1xuaW1wb3J0IHsgQWNjb3VudFdhbGxldCwgQ29tcGxldGVBZGRyZXNzLCBDb250cmFjdERlcGxveWVyLCBQWEUsIGNyZWF0ZVBYRUNsaWVudCwgd2FpdEZvclBYRSwgQXp0ZWNBZGRyZXNzIH0gZnJvbSAnQGF6dGVjL2F6dGVjLmpzJztcbmltcG9ydCB7IGdldEluaXRpYWxUZXN0QWNjb3VudHNXYWxsZXRzIH0gZnJvbSAnQGF6dGVjL2FjY291bnRzL3Rlc3RpbmcnO1xuaW1wb3J0IHsgRnIgfSBmcm9tICdAYXp0ZWMvY2lyY3VpdHMuanMnO1xuaW1wb3J0IHsgQnV0dG9uLCBTZWxlY3QsIFNwaW4sIG5vdGlmaWNhdGlvbiB9IGZyb20gJ2FudGQnO1xuaW1wb3J0IHsgUm9ja0ljb24sIFBhcGVySWNvbiwgU2Npc3NvcnNJY29uIH0gZnJvbSAnLi4vY29tcG9uZW50cy9JY29ucyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4uL3N0eWxlcy9Sb2NrUGFwZXJTY2lzc29ycy5tb2R1bGUuY3NzJztcblxudHlwZSBNb3ZlID0gJ1JvY2snIHwgJ1BhcGVyJyB8ICdTY2lzc29ycyc7XG5cbmNvbnN0IFJvY2tQYXBlclNjaXNzb3JzID0gKCkgPT4ge1xuICAgIGNvbnN0IFtweGUsIHNldFB4ZV0gPSB1c2VTdGF0ZTxQWEUgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbd2FsbGV0LCBzZXRXYWxsZXRdID0gdXNlU3RhdGU8QWNjb3VudFdhbGxldCB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IFtjb250cmFjdCwgc2V0Q29udHJhY3RdID0gdXNlU3RhdGU8RWFzeVByaXZhdGVWb3RpbmdDb250cmFjdCB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IFtzZWxlY3RlZE1vdmUsIHNldFNlbGVjdGVkTW92ZV0gPSB1c2VTdGF0ZTxNb3ZlIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgW2dhbWVTdGF0dXMsIHNldEdhbWVTdGF0dXNdID0gdXNlU3RhdGU8c3RyaW5nPignJyk7XG4gICAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgaW5pdGlhbGl6ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgUFhFX1VSTCA9ICdodHRwOi8vbG9jYWxob3N0OjgwODAnIH0gPSBwcm9jZXNzLmVudjtcbiAgICAgICAgICAgIGNvbnN0IHB4ZUNsaWVudCA9IGF3YWl0IGNyZWF0ZVBYRUNsaWVudChQWEVfVVJMKTtcbiAgICAgICAgICAgIGF3YWl0IHdhaXRGb3JQWEUocHhlQ2xpZW50KTtcbiAgICAgICAgICAgIHNldFB4ZShweGVDbGllbnQpO1xuXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHdhbGxldCBhbmQgY29udHJhY3RcbiAgICAgICAgICAgIGNvbnN0IFt3YWxsZXRJbnN0YW5jZV0gPSBhd2FpdCBnZXRJbml0aWFsVGVzdEFjY291bnRzV2FsbGV0cyhweGVDbGllbnQpO1xuICAgICAgICAgICAgc2V0V2FsbGV0KHdhbGxldEluc3RhbmNlKTtcblxuICAgICAgICAgICAgY29uc3QgZGVwbG95ZWRDb250cmFjdCA9IGF3YWl0IEVhc3lQcml2YXRlVm90aW5nQ29udHJhY3QuYXQoXG4gICAgICAgICAgICAgICAgQXp0ZWNBZGRyZXNzLmZyb21TdHJpbmcoJzB4WW91ckNvbnRyYWN0QWRkcmVzcycpLFxuICAgICAgICAgICAgICAgIHdhbGxldEluc3RhbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2V0Q29udHJhY3QoZGVwbG95ZWRDb250cmFjdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaW5pdGlhbGl6ZSgpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGhhbmRsZU1vdmVTZWxlY3Rpb24gPSAobW92ZTogTW92ZSkgPT4ge1xuICAgICAgICBzZXRTZWxlY3RlZE1vdmUobW92ZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHBsYXlNb3ZlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIWNvbnRyYWN0IHx8ICFzZWxlY3RlZE1vdmUpIHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5lcnJvcih7IG1lc3NhZ2U6ICdQbGVhc2Ugc2VsZWN0IGEgbW92ZS4nIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0R2FtZVN0YXR1cygnU3VibWl0dGluZyB5b3VyIG1vdmUuLi4nKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBtb3ZlIHRvIEZpZWxkIChhc3N1bWluZyBSb2NrPTAsIFBhcGVyPTEsIFNjaXNzb3JzPTIpXG4gICAgICAgICAgICBjb25zdCBtb3ZlVmFsdWUgPSBzZWxlY3RlZE1vdmUgPT09ICdSb2NrJyA/IDAgOiBzZWxlY3RlZE1vdmUgPT09ICdQYXBlcicgPyAxIDogMjtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkTW92ZSA9IG5ldyBGcihtb3ZlVmFsdWUpO1xuXG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0Lm1ldGhvZHMuY2FzdF92b3RlKGZpZWxkTW92ZSkuc2VuZCgpLndhaXQoKTtcbiAgICAgICAgICAgIHNldEdhbWVTdGF0dXMoJ01vdmUgc3VibWl0dGVkISBXYWl0aW5nIGZvciBvcHBvbmVudC4uLicpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGZXRjaCBhbmQgZGlzcGxheSBnYW1lIHJlc3VsdFxuICAgICAgICAgICAgLy8gUmVwbGFjZSB3aXRoIGFjdHVhbCBnYW1lIHJlc3VsdCBmZXRjaGluZyBsb2dpY1xuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgICAgICAgICAvLyBjb25zdCByZXN1bHQgPSBhd2FpdCBjb250cmFjdC5tZXRob2RzLmdldF9nYW1lX3Jlc3VsdCgpLnNpbXVsYXRlKCk7XG4gICAgICAgICAgICAvLyBzZXRHYW1lU3RhdHVzKGBHYW1lIFJlc3VsdDogJHtyZXN1bHR9YCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgc2V0R2FtZVN0YXR1cygnQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgc3VibWl0dGluZyB5b3VyIG1vdmUuJyk7XG4gICAgICAgICAgICBub3RpZmljYXRpb24uZXJyb3IoeyBtZXNzYWdlOiAnRXJyb3InLCBkZXNjcmlwdGlvbjogZXJyb3IubWVzc2FnZSB9KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY29udGFpbmVyfT5cbiAgICAgICAgICAgIDxoMT5Sb2NrIFBhcGVyIFNjaXNzb3JzPC9oMT5cbiAgICAgICAgICAgIHshd2FsbGV0ID8gKFxuICAgICAgICAgICAgICAgIDxCdXR0b24gdHlwZT1cInByaW1hcnlcIiBvbkNsaWNrPXsoKSA9PiB7LyogSW1wbGVtZW50IHdhbGxldCBjb25uZWN0aW9uICovfX0+XG4gICAgICAgICAgICAgICAgICAgIENvbm5lY3QgV2FsbGV0XG4gICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubW92ZXN9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBpY29uPXs8Um9ja0ljb24gLz59IG9uQ2xpY2s9eygpID0+IGhhbmRsZU1vdmVTZWxlY3Rpb24oJ1JvY2snKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUm9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIGljb249ezxQYXBlckljb24gLz59IG9uQ2xpY2s9eygpID0+IGhhbmRsZU1vdmVTZWxlY3Rpb24oJ1BhcGVyJyl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBhcGVyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24gaWNvbj17PFNjaXNzb3JzSWNvbiAvPn0gb25DbGljaz17KCkgPT4gaGFuZGxlTW92ZVNlbGVjdGlvbignU2Npc3NvcnMnKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2Npc3NvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiB0eXBlPVwicHJpbWFyeVwiIG9uQ2xpY2s9e3BsYXlNb3ZlfSBkaXNhYmxlZD17IXNlbGVjdGVkTW92ZSB8fCBsb2FkaW5nfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtsb2FkaW5nID8gPFNwaW4gLz4gOiAnUGxheSd9XG4gICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICB7Z2FtZVN0YXR1cyAmJiA8cCBjbGFzc05hbWU9e3N0eWxlcy5zdGF0dXN9PntnYW1lU3RhdHVzfTwvcD59XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgUm9ja1BhcGVyU2Npc3NvcnM7ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIkVhc3lQcml2YXRlVm90aW5nQ29udHJhY3QiLCJjcmVhdGVQWEVDbGllbnQiLCJ3YWl0Rm9yUFhFIiwiQXp0ZWNBZGRyZXNzIiwiZ2V0SW5pdGlhbFRlc3RBY2NvdW50c1dhbGxldHMiLCJGciIsIkJ1dHRvbiIsIlNwaW4iLCJub3RpZmljYXRpb24iLCJSb2NrSWNvbiIsIlBhcGVySWNvbiIsIlNjaXNzb3JzSWNvbiIsInN0eWxlcyIsIlJvY2tQYXBlclNjaXNzb3JzIiwicHhlIiwic2V0UHhlIiwid2FsbGV0Iiwic2V0V2FsbGV0IiwiY29udHJhY3QiLCJzZXRDb250cmFjdCIsInNlbGVjdGVkTW92ZSIsInNldFNlbGVjdGVkTW92ZSIsImdhbWVTdGF0dXMiLCJzZXRHYW1lU3RhdHVzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJpbml0aWFsaXplIiwiUFhFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJweGVDbGllbnQiLCJ3YWxsZXRJbnN0YW5jZSIsImRlcGxveWVkQ29udHJhY3QiLCJhdCIsImZyb21TdHJpbmciLCJoYW5kbGVNb3ZlU2VsZWN0aW9uIiwibW92ZSIsInBsYXlNb3ZlIiwiZXJyb3IiLCJtZXNzYWdlIiwibW92ZVZhbHVlIiwiZmllbGRNb3ZlIiwidHgiLCJtZXRob2RzIiwiY2FzdF92b3RlIiwic2VuZCIsIndhaXQiLCJjb25zb2xlIiwiZGVzY3JpcHRpb24iLCJkaXYiLCJjbGFzc05hbWUiLCJjb250YWluZXIiLCJoMSIsInR5cGUiLCJvbkNsaWNrIiwibW92ZXMiLCJpY29uIiwiZGlzYWJsZWQiLCJwIiwic3RhdHVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pages/RockPaperScissors.tsx\n");

/***/ }),

/***/ "@ant-design/colors":
/*!*************************************!*\
  !*** external "@ant-design/colors" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@ant-design/colors");

/***/ }),

/***/ "@ant-design/cssinjs":
/*!**************************************!*\
  !*** external "@ant-design/cssinjs" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@ant-design/cssinjs");

/***/ }),

/***/ "@ant-design/cssinjs-utils":
/*!********************************************!*\
  !*** external "@ant-design/cssinjs-utils" ***!
  \********************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@ant-design/cssinjs-utils");

/***/ }),

/***/ "@ant-design/icons/es/components/Context":
/*!**********************************************************!*\
  !*** external "@ant-design/icons/es/components/Context" ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@ant-design/icons/es/components/Context");

/***/ }),

/***/ "@ant-design/icons/es/icons/CheckCircleFilled":
/*!***************************************************************!*\
  !*** external "@ant-design/icons/es/icons/CheckCircleFilled" ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@ant-design/icons/es/icons/CheckCircleFilled");

/***/ }),

/***/ "@ant-design/icons/es/icons/CloseCircleFilled":
/*!***************************************************************!*\
  !*** external "@ant-design/icons/es/icons/CloseCircleFilled" ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@ant-design/icons/es/icons/CloseCircleFilled");

/***/ }),

/***/ "@ant-design/icons/es/icons/CloseOutlined":
/*!***********************************************************!*\
  !*** external "@ant-design/icons/es/icons/CloseOutlined" ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@ant-design/icons/es/icons/CloseOutlined");

/***/ }),

/***/ "@ant-design/icons/es/icons/ExclamationCircleFilled":
/*!*********************************************************************!*\
  !*** external "@ant-design/icons/es/icons/ExclamationCircleFilled" ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@ant-design/icons/es/icons/ExclamationCircleFilled");

/***/ }),

/***/ "@ant-design/icons/es/icons/InfoCircleFilled":
/*!**************************************************************!*\
  !*** external "@ant-design/icons/es/icons/InfoCircleFilled" ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@ant-design/icons/es/icons/InfoCircleFilled");

/***/ }),

/***/ "@ant-design/icons/es/icons/LoadingOutlined":
/*!*************************************************************!*\
  !*** external "@ant-design/icons/es/icons/LoadingOutlined" ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@ant-design/icons/es/icons/LoadingOutlined");

/***/ }),

/***/ "@ant-design/icons/es/icons/RightOutlined":
/*!***********************************************************!*\
  !*** external "@ant-design/icons/es/icons/RightOutlined" ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@ant-design/icons/es/icons/RightOutlined");

/***/ }),

/***/ "@ctrl/tinycolor":
/*!**********************************!*\
  !*** external "@ctrl/tinycolor" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@ctrl/tinycolor");

/***/ }),

/***/ "@rc-component/color-picker":
/*!*********************************************!*\
  !*** external "@rc-component/color-picker" ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@rc-component/color-picker");

/***/ }),

/***/ "classnames":
/*!*****************************!*\
  !*** external "classnames" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("classnames");

/***/ }),

/***/ "next/dist/compiled/next-server/pages.runtime.dev.js":
/*!**********************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages.runtime.dev.js" ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/pages.runtime.dev.js");

/***/ }),

/***/ "rc-collapse":
/*!******************************!*\
  !*** external "rc-collapse" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-collapse");

/***/ }),

/***/ "rc-motion":
/*!****************************!*\
  !*** external "rc-motion" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-motion");

/***/ }),

/***/ "rc-notification":
/*!**********************************!*\
  !*** external "rc-notification" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-notification");

/***/ }),

/***/ "rc-pagination/es/locale/en_US":
/*!************************************************!*\
  !*** external "rc-pagination/es/locale/en_US" ***!
  \************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-pagination/es/locale/en_US");

/***/ }),

/***/ "rc-picker/es/locale/en_US":
/*!********************************************!*\
  !*** external "rc-picker/es/locale/en_US" ***!
  \********************************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-picker/es/locale/en_US");

/***/ }),

/***/ "rc-util/es/Children/toArray":
/*!**********************************************!*\
  !*** external "rc-util/es/Children/toArray" ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-util/es/Children/toArray");

/***/ }),

/***/ "rc-util/es/Dom/canUseDom":
/*!*******************************************!*\
  !*** external "rc-util/es/Dom/canUseDom" ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-util/es/Dom/canUseDom");

/***/ }),

/***/ "rc-util/es/Dom/dynamicCSS":
/*!********************************************!*\
  !*** external "rc-util/es/Dom/dynamicCSS" ***!
  \********************************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-util/es/Dom/dynamicCSS");

/***/ }),

/***/ "rc-util/es/Dom/isVisible":
/*!*******************************************!*\
  !*** external "rc-util/es/Dom/isVisible" ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-util/es/Dom/isVisible");

/***/ }),

/***/ "rc-util/es/React/render":
/*!******************************************!*\
  !*** external "rc-util/es/React/render" ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-util/es/React/render");

/***/ }),

/***/ "rc-util/es/hooks/useEvent":
/*!********************************************!*\
  !*** external "rc-util/es/hooks/useEvent" ***!
  \********************************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-util/es/hooks/useEvent");

/***/ }),

/***/ "rc-util/es/hooks/useLayoutEffect":
/*!***************************************************!*\
  !*** external "rc-util/es/hooks/useLayoutEffect" ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-util/es/hooks/useLayoutEffect");

/***/ }),

/***/ "rc-util/es/hooks/useMemo":
/*!*******************************************!*\
  !*** external "rc-util/es/hooks/useMemo" ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-util/es/hooks/useMemo");

/***/ }),

/***/ "rc-util/es/hooks/useMergedState":
/*!**************************************************!*\
  !*** external "rc-util/es/hooks/useMergedState" ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-util/es/hooks/useMergedState");

/***/ }),

/***/ "rc-util/es/isEqual":
/*!*************************************!*\
  !*** external "rc-util/es/isEqual" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-util/es/isEqual");

/***/ }),

/***/ "rc-util/es/omit":
/*!**********************************!*\
  !*** external "rc-util/es/omit" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-util/es/omit");

/***/ }),

/***/ "rc-util/es/raf":
/*!*********************************!*\
  !*** external "rc-util/es/raf" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-util/es/raf");

/***/ }),

/***/ "rc-util/es/ref":
/*!*********************************!*\
  !*** external "rc-util/es/ref" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-util/es/ref");

/***/ }),

/***/ "rc-util/es/utils/set":
/*!***************************************!*\
  !*** external "rc-util/es/utils/set" ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-util/es/utils/set");

/***/ }),

/***/ "rc-util/es/warning":
/*!*************************************!*\
  !*** external "rc-util/es/warning" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = require("rc-util/es/warning");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("react");

/***/ }),

/***/ "react-dom":
/*!****************************!*\
  !*** external "react-dom" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-dom");

/***/ }),

/***/ "react/jsx-dev-runtime":
/*!****************************************!*\
  !*** external "react/jsx-dev-runtime" ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("react/jsx-dev-runtime");

/***/ }),

/***/ "react/jsx-runtime":
/*!************************************!*\
  !*** external "react/jsx-runtime" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("react/jsx-runtime");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "@aztec/accounts/testing":
/*!******************************************!*\
  !*** external "@aztec/accounts/testing" ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = import("@aztec/accounts/testing");;

/***/ }),

/***/ "@aztec/aztec.js":
/*!**********************************!*\
  !*** external "@aztec/aztec.js" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = import("@aztec/aztec.js");;

/***/ }),

/***/ "@aztec/circuits.js":
/*!*************************************!*\
  !*** external "@aztec/circuits.js" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = import("@aztec/circuits.js");;

/***/ }),

/***/ "throttle-debounce":
/*!************************************!*\
  !*** external "throttle-debounce" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = import("throttle-debounce");;

/***/ }),

/***/ "./target/easy_private_voting_contract-EasyPrivateVoting.json":
/*!********************************************************************!*\
  !*** ./target/easy_private_voting_contract-EasyPrivateVoting.json ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"transpiled":true,"noir_version":"1.0.0-beta.0+8079d640b38957b4","name":"EasyPrivateVoting","functions":[{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"]},{"name":"cast_vote","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"candidate","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"inner","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"fields":[{"name":"log","type":{"fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}],"kind":"struct","path":"aztec::protocol_types::abis::log::Log"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData"}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"max_priority_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_public_keys_and_partial_address","decompose_hint","lte_hint","get_key_validation_request","pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","directive_integer_quotient","directive_invert"],"verification_key":"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"},{"name":"end_vote","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"8095637994846897154":{"error_kind":"string","string":"Only admin can end votes"}},"parameters":[],"return_type":null},"bytecode":"JgACBAEnAAABBIBDJgAABAMmAgEEACYCAgQAHxgAAgABgEMkAAAAOicCAAEEgEMmAgIEADoNAAEAAiQAAACRHgIAAQAeAgACADI4AAEAAgADJgIBAQEjAgADAAAAYyQAAAC6JgIBAAEuDAABAAIeAgADAQo4AgMEIwIABAAAAIUkAAAAzCYCAgADLwwAAQACJScAgAQEeAANAAAAgASAAyMAgAMAAAC5KQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQVwWXvdIQFEAjsBAQIlLQAYyhjK","debug_symbols":"5VbbisIwEP2XPPchM5NMEn9lWZaqVQqllVoXFvHfdyqmVls2ILovvpROOZlz5pLpHNW6WB62X2W9afZq8XFUVbPKu7KpxTqeMrVsy6oqt1/jz0r3D6Yzfr/L697cd3nbqQVw0Jkq6rW8Oq3Fw6asCrVgPGVTsNY2gjXaAQyGZtCGvL+gDQU3QocZtAeKvj1YuEF/Zor9E9R7jGCR/5/q3TNyb2DIPadyD5aierDBJNQHxOg7IJt79R6eqh70rfqegV/NEMzLGcIcA+ohtagpJBjE1cDA/srQs03QDoEvaIeU6lAJz0W0NpxAy11xgxQdNN/3hCTjrcIFPR+usUO4TH+Ha6yNHMYypCaKpDJOFAQ3FWST+WceC+oPoX7kkH/gEM1OPASKNZRqpu4bYSyhTFdKtQdz1OPYU6o9DMdaOAsm2R7h5tdBk2qQf59wT2J+522ZL6visnVsDvVqtIR0P7vibh/Ztc2qWB/aot9MrkvJ+VohZwTnnhZD/qPkhEN4fgE=","brillig_names":["end_vote"]},{"name":"add_to_tally_public","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2024020833944022298":{"error_kind":"string","string":"Function add_to_tally_public can only be called internally"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"3557153117338734214":{"error_kind":"string","string":"Vote has ended"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"candidate","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["add_to_tally_public"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16541607464495309456":{"error_kind":"fmtstring","item_types":[],"length":16},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/9VZ227aQBBdsI2xiQmFP4jUt1ayCdc3pF7yHSiBL+gH+KEv7VeXFTv2YTypkJipykjRGs/6zNkz4931pufONjz99cJ1HNqB6xr12YW2vM0qRazSkmfvTnj274RndCc8Y0WePYGnb+l9S9z5nUvd+X3sOPFhn+gI/O5vQCzo79Bmoe2DXzExVSYMVgt/Uy5eM3dpyvyfs4CZ2uAvCX9og18S7y91i49jobhRaF/qVssXeMZbEa6xiAmXfH3wfWW+CHzfmA9r+DvzYd0TJ9JtAGNRrKuNdV5obCmMrfdO61yrHd4jrXNnWqMV5TxjfDh/4lNQn7rlM2C+GHwZ8yXgI/19+wT9eO5T6PcZ7vOajFy3hslPOUetLWoqNsA/2ULSneckri9jow91j0HPJ6aPxVqB+ljo7/WZvcOfrr2ltWssYnqiRqTZEPszXwa+uL6Mk4ffMcRBLOKRsP6fwu/H0A7gGXp+IsQfsPgXvIV7qBHHioR71N+/kx/D9cid6+cn9XfdeUpvU71aSHO2Hv66wc9s+B8JP7fBXxH+yAa/2cs8mODPS8IvbPhvCX9sUz/NXvLRhv+B8Ccm+IsDrbsfXGvN/BCup3Bfb+6uqmv2RBg/Z1yt9kRTxofrg+uv980ErhPBx3M4E+LMhDgSVqaI9aCI9fifjnGoiDVSxBorYmnmMVXE0tQrV8QqFLE0615TL8qjtE/ztgtteaNJ+zRF/Erap2l+u5PWVF+xoCGOL2H9fzCdRyY8qzmtOfSuUwyMXRjFvna9pviFwId454LvlkPZw3Jz3G6W29OWrFrNt00+C8aV38NvIpyPsb+09kv7PkWtS+m7fwy6eovBVzBfAj7iKH33j434X6M/xp8IPr7+X5vLqeuuhyM2bjzj2qmMuT3/k87mjeev5bXvJsXPXXe+/lfni6gP30vnAteJ4OP7k1yIkwtx7hGLn9Gjhr6uSae4bv1auVxv2n9w0VyUuMtzf8fiJ6z/r/Abx0btLXP+cb2vjs/74365f3tbvO6nDN9bH3T6A/vRhmkVHwAA","debug_symbols":"tdfNaoQwFAXgd8k6C29+jPFVShmixiEQokQtFPHdG4dpO8wsh7MRrly/gHiQs7PBd9v1EtI4Laz92FmcereGKZVpPzjrcogxXC+Pt1l1Xqy87S+zS+e4rC6vrFWCM58G1uqqPD2G6Flbi4O/LJrfRWP+FrU4PjmzCgVrFFyjYIOCGxRsQTBVFUwmmCxgsoTJCiZrmFzDZAOTG5gMyyDBMkiwDBIsgwTLIMEySLAM0nsZtPK+WF7rC21wdIOjLYwWFY4mHC1wtMTRCkdrHI1Lo8ClUeDSKEBpPMr05XJwXfT3zjRuqX+oUOv37J/a1Jyn3g9b9mev+q9U50csFVfq9hcvA0nBSZpySDnoBw==","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"16541607464495309456":{"error_kind":"fmtstring","item_types":[],"length":16},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"2024020833944022298":{"error_kind":"string","string":"Function add_to_tally_public can only be called internally"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"3557153117338734214":{"error_kind":"string","string":"Vote has ended"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"8095637994846897154":{"error_kind":"string","string":"Only admin can end votes"}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"]},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}},"parameters":[],"return_type":null},"bytecode":"H4sIAAAAAAAA/9VUyw6CMBBseURBOaiJ3kz8gyIYOJJ49x8akKMe8OKNT5eabbqpVRKlJkzSbEs3szNlW0oUKESPvAH9tGnIFdhBDCA6aN/tRgFr9hviQKs7JH/O0iQw+BtQ/5OfWtIvIPktnT+bAM+xVfzYi6w77UaIesKWZ/nPbHpe9fhc/MFnh32k1caghm+uIYci3RuYR4Y8iRlRd9prh/eV5YzJei7w++RVO67va/lrWIeafvmOFV/qrDMe1wmv+YFXVVrypcYv4KBzGnMvbGHe1wvY45yo3mjul/J0vZ0b0gNB8gCVxsvQjgYAAA==","debug_symbols":"nZLRCoMgGIXf5b/uIk0rfZUYYWUhiIbZYETvPtvaaKMbu/nhyPnOjd8CnWzmoVamtxPwagFtW+GVNSEtawKNU1qroT4+Q7odhF79aRRmi5MXzgMnOAFpOuA0DXSvtASe4/WWAMKR/SyyTyL7NK6PT/cZQWwnGCH5lyneDL3A5BeY4gJTxjPZ6Z8zmpYfhuLih1lDugunRKPlrlQ/m/ZgmH+M8k+20dlWdrOTm3YH48KtUJFgHGbD9BM=","brillig_names":["sync_notes"]},{"name":"get_vote","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}},"parameters":[{"name":"candidate","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_vote"]}],"outputs":{"globals":{"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"EasyPrivateVoting"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"tally","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"vote_ended","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"active_at_block","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"candidate","type":{"kind":"field"}}],"kind":"struct","path":"EasyPrivateVoting::cast_vote_parameters"}}],"kind":"struct","path":"EasyPrivateVoting::cast_vote_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"candidate","type":{"kind":"field"}}],"kind":"struct","path":"EasyPrivateVoting::add_to_tally_public_parameters"}}],"kind":"struct","path":"EasyPrivateVoting::add_to_tally_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"EasyPrivateVoting::constructor_parameters"}}],"kind":"struct","path":"EasyPrivateVoting::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"EasyPrivateVoting::end_vote_parameters"}}],"kind":"struct","path":"EasyPrivateVoting::end_vote_abi"}]}},"file_map":{"17":{"path":"std/embedded_curve_ops.nr","source":"use crate::cmp::Eq;\\nuse crate::ops::arith::{Add, Neg, Sub};\\n\\n/// A point on the embedded elliptic curve\\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\\npub struct EmbeddedCurvePoint {\\n    pub x: Field,\\n    pub y: Field,\\n    pub is_infinite: bool,\\n}\\n\\nimpl EmbeddedCurvePoint {\\n    /// Elliptic curve point doubling operation\\n    /// returns the doubled point of a point P, i.e P+P\\n    pub fn double(self) -> EmbeddedCurvePoint {\\n        embedded_curve_add(self, self)\\n    }\\n\\n    /// Returns the null element of the curve; \'the point at infinity\'\\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\\n    }\\n}\\n\\nimpl Add for EmbeddedCurvePoint {\\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\\n        embedded_curve_add(self, other)\\n    }\\n}\\n\\nimpl Sub for EmbeddedCurvePoint {\\n    /// Points subtraction operation, using addition and negation\\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\\n        self + other.neg()\\n    }\\n}\\n\\nimpl Neg for EmbeddedCurvePoint {\\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\\n    /// If the point is at infinity, then the result is also at infinity.\\n    fn neg(self) -> EmbeddedCurvePoint {\\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\\n    }\\n}\\n\\nimpl Eq for EmbeddedCurvePoint {\\n    /// Checks whether two points are equal\\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\\n        (self.is_infinite & b.is_infinite)\\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\\n    }\\n}\\n\\n/// Scalar for the embedded curve represented as low and high limbs\\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\\npub struct EmbeddedCurveScalar {\\n    pub lo: Field,\\n    pub hi: Field,\\n}\\n\\nimpl EmbeddedCurveScalar {\\n    pub fn new(lo: Field, hi: Field) -> Self {\\n        EmbeddedCurveScalar { lo, hi }\\n    }\\n\\n    #[field(bn254)]\\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\\n        let (a, b) = crate::field::bn254::decompose(scalar);\\n        EmbeddedCurveScalar { lo: a, hi: b }\\n    }\\n\\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\\n    #[field(bn254)]\\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\\n        let mut v = 1;\\n        let mut lo = 0 as Field;\\n        let mut hi = 0 as Field;\\n        for i in 0..16 {\\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\\n            v = v * 256;\\n        }\\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\\n        sig_s\\n    }\\n}\\n\\nimpl Eq for EmbeddedCurveScalar {\\n    fn eq(self, other: Self) -> bool {\\n        (other.hi == self.hi) & (other.lo == self.lo)\\n    }\\n}\\n\\n// Computes a multi scalar multiplication over the embedded curve.\\n// For bn254, We have Grumpkin and Baby JubJub.\\n// For bls12-381, we have JubJub and Bandersnatch.\\n//\\n// The embedded curve being used is decided by the\\n// underlying proof system.\\n// docs:start:multi_scalar_mul\\npub fn multi_scalar_mul<let N: u32>(\\n    points: [EmbeddedCurvePoint; N],\\n    scalars: [EmbeddedCurveScalar; N],\\n) -> EmbeddedCurvePoint\\n// docs:end:multi_scalar_mul\\n{\\n    let point_array = multi_scalar_mul_array_return(points, scalars);\\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\\n}\\n\\n#[foreign(multi_scalar_mul)]\\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\\n    points: [EmbeddedCurvePoint; N],\\n    scalars: [EmbeddedCurveScalar; N],\\n) -> [Field; 3] {}\\n\\n// docs:start:fixed_base_scalar_mul\\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\\n// docs:end:fixed_base_scalar_mul\\n{\\n    let g1 = EmbeddedCurvePoint {\\n        x: 1,\\n        y: 17631683881184975370165255887551781615748388533673675138860,\\n        is_infinite: false,\\n    };\\n    multi_scalar_mul([g1], [scalar])\\n}\\n\\n/// This function only assumes that the points are on the curve\\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\\n// docs:start:embedded_curve_add\\npub fn embedded_curve_add(\\n    point1: EmbeddedCurvePoint,\\n    point2: EmbeddedCurvePoint,\\n) -> EmbeddedCurvePoint {\\n    // docs:end:embedded_curve_add\\n    let x_coordinates_match = point1.x == point2.x;\\n    let y_coordinates_match = point1.y == point2.y;\\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\\n    let point1_1 = EmbeddedCurvePoint {\\n        x: point1.x + (x_coordinates_match as Field),\\n        y: point1.y,\\n        is_infinite: x_coordinates_match,\\n    };\\n    // point1_1 is guaranteed to have a different abscissa than point2\\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\\n    result.is_infinite = x_coordinates_match;\\n\\n    // dbl if x_match, y_match\\n    let double = embedded_curve_add_unsafe(point1, point1);\\n    result = if double_predicate { double } else { result };\\n\\n    // infinity if x_match, !y_match\\n    if point1.is_infinite {\\n        result = point2;\\n    }\\n    if point2.is_infinite {\\n        result = point1;\\n    }\\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\\n    result\\n}\\n\\n#[foreign(embedded_curve_add)]\\nfn embedded_curve_add_array_return(\\n    _point1: EmbeddedCurvePoint,\\n    _point2: EmbeddedCurvePoint,\\n) -> [Field; 3] {}\\n\\n/// This function assumes that:\\n/// The points are on the curve, and\\n/// The points don\'t share an x-coordinate, and\\n/// Neither point is the infinity point.\\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\\npub fn embedded_curve_add_not_nul(\\n    point1: EmbeddedCurvePoint,\\n    point2: EmbeddedCurvePoint,\\n) -> EmbeddedCurvePoint {\\n    assert(point1.x != point2.x);\\n    assert(!point1.is_infinite);\\n    assert(!point2.is_infinite);\\n    embedded_curve_add_unsafe(point1, point2)\\n}\\n\\n/// Unsafe ec addition\\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\\n/// If they have the same value but are different variables, the result will be incorrect because in this case\\n/// it assumes (but does not check) that the points\' x-coordinates are not equal.\\n/// It also assumes neither point is the infinity point.\\npub fn embedded_curve_add_unsafe(\\n    point1: EmbeddedCurvePoint,\\n    point2: EmbeddedCurvePoint,\\n) -> EmbeddedCurvePoint {\\n    let point_array = embedded_curve_add_array_return(point1, point2);\\n    let x = point_array[0];\\n    let y = point_array[1];\\n\\n    EmbeddedCurvePoint { x, y, is_infinite: false }\\n}\\n"},"18":{"path":"std/field/bn254.nr","source":"use crate::field::field_less_than;\\nuse crate::runtime::is_unconstrained;\\n\\n// The low and high decomposition of the field modulus\\nglobal PLO: Field = 53438638232309528389504892708671455233;\\nglobal PHI: Field = 64323764613183177041862057485226039389;\\n\\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\\nglobal TWO_POW_64: Field = 0x10000000000000000;\\n\\n// Decomposes a single field into two 16 byte fields.\\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\\n    // Here\'s we\'re taking advantage of truncating 64 bit limbs from the input field\\n    // and then subtracting them from the input such the field division is equivalent to integer division.\\n    let low_lower_64 = (x as u64) as Field;\\n    x = (x - low_lower_64) / TWO_POW_64;\\n    let low_upper_64 = (x as u64) as Field;\\n\\n    let high = (x - low_upper_64) / TWO_POW_64;\\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\\n\\n    (low, high)\\n}\\n\\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\\n    compute_decomposition(x)\\n}\\n\\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\\n    if x == y {\\n        true\\n    } else {\\n        field_less_than(x, y)\\n    }\\n}\\n\\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\\n    let (alo, ahi) = a;\\n    let (blo, bhi) = b;\\n    unsafe {\\n        /*@safety: borrow is enforced to be boolean due to its type.\\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\\n        */\\n        let borrow = lte_hint(alo, blo);\\n\\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\\n        let rhi = ahi - bhi - (borrow as Field);\\n\\n        rlo.assert_max_bit_size::<128>();\\n        rhi.assert_max_bit_size::<128>();\\n    }\\n}\\n\\n/// Decompose a single field into two 16 byte fields.\\npub fn decompose(x: Field) -> (Field, Field) {\\n    if is_unconstrained() {\\n        compute_decomposition(x)\\n    } else {\\n        unsafe {\\n            /*@safety: decomposition is properly checked below*/\\n            // Take hints of the decomposition\\n            let (xlo, xhi) = decompose_hint(x);\\n\\n            // Range check the limbs\\n            xlo.assert_max_bit_size::<128>();\\n            xhi.assert_max_bit_size::<128>();\\n\\n            // Check that the decomposition is correct\\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\\n\\n            // Assert that the decomposition of P is greater than the decomposition of x\\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\\n            (xlo, xhi)\\n        }\\n    }\\n}\\n\\npub fn assert_gt(a: Field, b: Field) {\\n    if is_unconstrained() {\\n        assert(\\n            unsafe {\\n                //@safety: already unconstrained\\n                field_less_than(b, a)\\n            },\\n        );\\n    } else {\\n        // Decompose a and b\\n        let a_limbs = decompose(a);\\n        let b_limbs = decompose(b);\\n\\n        // Assert that a_limbs is greater than b_limbs\\n        assert_gt_limbs(a_limbs, b_limbs)\\n    }\\n}\\n\\npub fn assert_lt(a: Field, b: Field) {\\n    assert_gt(b, a);\\n}\\n\\npub fn gt(a: Field, b: Field) -> bool {\\n    if is_unconstrained() {\\n        unsafe {\\n            //@safety: unsafe in unconstrained\\n            field_less_than(b, a)\\n        }\\n    } else if a == b {\\n        false\\n    } else {\\n        unsafe {\\n            //@safety: Take a hint of the comparison and verify it\\n            if field_less_than(a, b) {\\n                assert_gt(b, a);\\n                false\\n            } else {\\n                assert_gt(a, b);\\n                true\\n            }\\n        }\\n    }\\n}\\n\\npub fn lt(a: Field, b: Field) -> bool {\\n    gt(b, a)\\n}\\n\\nmod tests {\\n    // TODO: Allow imports from \\"super\\"\\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\\n\\n    #[test]\\n    fn check_decompose() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_decompose_unconstrained() {\\n        assert_eq(decompose(TWO_POW_128), (0, 1));\\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_lte_hint() {\\n        assert(lte_hint(0, 1));\\n        assert(lte_hint(0, 0x100));\\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\\n        assert(!lte_hint(0 - 1, 0));\\n\\n        assert(lte_hint(0, 0));\\n        assert(lte_hint(0x100, 0x100));\\n        assert(lte_hint(0 - 1, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_assert_gt() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    unconstrained fn check_assert_gt_unconstrained() {\\n        assert_gt(1, 0);\\n        assert_gt(0x100, 0);\\n        assert_gt((0 - 1), (0 - 2));\\n        assert_gt(TWO_POW_128, 0);\\n        assert_gt(0 - 1, 0);\\n    }\\n\\n    #[test]\\n    fn check_gt() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    unconstrained fn check_gt_unconstrained() {\\n        assert(gt(1, 0));\\n        assert(gt(0x100, 0));\\n        assert(gt((0 - 1), (0 - 2)));\\n        assert(gt(TWO_POW_128, 0));\\n        assert(!gt(0, 0));\\n        assert(!gt(0, 0x100));\\n        assert(gt(0 - 1, 0 - 2));\\n        assert(!gt(0 - 2, 0 - 1));\\n    }\\n\\n    #[test]\\n    fn check_plo_phi() {\\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\\n        let p_bytes = crate::field::modulus_le_bytes();\\n        let mut p_low: Field = 0;\\n        let mut p_high: Field = 0;\\n\\n        let mut offset = 1;\\n        for i in 0..16 {\\n            p_low += (p_bytes[i] as Field) * offset;\\n            p_high += (p_bytes[i + 16] as Field) * offset;\\n            offset *= 256;\\n        }\\n        assert_eq(p_low, PLO);\\n        assert_eq(p_high, PHI);\\n    }\\n}\\n"},"19":{"path":"std/field/mod.nr","source":"pub mod bn254;\\nuse crate::runtime::is_unconstrained;\\nuse bn254::lt as bn254_lt;\\n\\nimpl Field {\\n    /// Asserts that `self` can be represented in `bit_size` bits.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\\n    // docs:start:assert_max_bit_size\\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\\n        // docs:end:assert_max_bit_size\\n        assert(BIT_SIZE < modulus_num_bits() as u32);\\n        self.__assert_max_bit_size(BIT_SIZE);\\n    }\\n\\n    #[builtin(apply_range_constraint)]\\n    fn __assert_max_bit_size(self, bit_size: u32) {}\\n\\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_le_bits)]\\n    // docs:start:to_le_bits\\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\\n    // docs:end:to_le_bits\\n\\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\\n    /// be able to represent the original `Field`.\\n    ///\\n    /// # Safety\\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\\n    /// wrap around due to overflow when verifying the decomposition.\\n    #[builtin(to_be_bits)]\\n    // docs:start:to_be_bits\\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\\n    // docs:end:to_be_bits\\n\\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_le_bytes\\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_le_bytes\\n        // Compute the byte decomposition\\n        let bytes = self.to_le_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_le_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\\n    ///\\n    /// # Failures\\n    ///  The length N of the array must be big enough to contain all the bytes of the \'self\',\\n    ///  and no more than the number of bytes required to represent the field modulus\\n    ///\\n    /// # Safety\\n    /// The result is ensured to be the canonical decomposition of the field element\\n    // docs:start:to_be_bytes\\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\\n        // docs:end:to_be_bytes\\n        // Compute the byte decomposition\\n        let bytes = self.to_be_radix(256);\\n\\n        if !is_unconstrained() {\\n            // Ensure that the byte decomposition does not overflow the modulus\\n            let p = modulus_be_bytes();\\n            assert(bytes.len() <= p.len());\\n            let mut ok = bytes.len() != p.len();\\n            for i in 0..N {\\n                if !ok {\\n                    if (bytes[i] != p[i]) {\\n                        assert(bytes[i] < p[i]);\\n                        ok = true;\\n                    }\\n                }\\n            }\\n            assert(ok);\\n        }\\n        bytes\\n    }\\n\\n    // docs:start:to_le_radix\\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            crate::assert_constant(radix);\\n        }\\n        self.__to_le_radix(radix)\\n    }\\n    // docs:end:to_le_radix\\n\\n    // docs:start:to_be_radix\\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\\n        // Brillig does not need an immediate radix\\n        if !crate::runtime::is_unconstrained() {\\n            crate::assert_constant(radix);\\n        }\\n        self.__to_be_radix(radix)\\n    }\\n    // docs:end:to_be_radix\\n\\n    // `_radix` must be less than 256\\n    #[builtin(to_le_radix)]\\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    #[builtin(to_be_radix)]\\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\\n\\n    // Returns self to the power of the given exponent value.\\n    // Caution: we assume the exponent fits into 32 bits\\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\\n    pub fn pow_32(self, exponent: Field) -> Field {\\n        let mut r: Field = 1;\\n        let b: [u1; 32] = exponent.to_le_bits();\\n\\n        for i in 1..33 {\\n            r *= r;\\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\\n        }\\n        r\\n    }\\n\\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\\n    pub fn sgn0(self) -> u1 {\\n        self as u1\\n    }\\n\\n    pub fn lt(self, another: Field) -> bool {\\n        if crate::compat::is_bn254() {\\n            bn254_lt(self, another)\\n        } else {\\n            lt_fallback(self, another)\\n        }\\n    }\\n\\n    /// Convert a little endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n\\n    /// Convert a big endian byte array to a field element.\\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\\n        let mut v = 1;\\n        let mut result = 0;\\n\\n        for i in 0..N {\\n            result += (bytes[N - 1 - i] as Field) * v;\\n            v = v * 256;\\n        }\\n        result\\n    }\\n}\\n\\n#[builtin(modulus_num_bits)]\\npub comptime fn modulus_num_bits() -> u64 {}\\n\\n#[builtin(modulus_be_bits)]\\npub comptime fn modulus_be_bits() -> [u1] {}\\n\\n#[builtin(modulus_le_bits)]\\npub comptime fn modulus_le_bits() -> [u1] {}\\n\\n#[builtin(modulus_be_bytes)]\\npub comptime fn modulus_be_bytes() -> [u8] {}\\n\\n#[builtin(modulus_le_bytes)]\\npub comptime fn modulus_le_bytes() -> [u8] {}\\n\\n/// An unconstrained only built in to efficiently compare fields.\\n#[builtin(field_less_than)]\\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\\n\\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\\n    __field_less_than(x, y)\\n}\\n\\n// Convert a 32 byte array to a field element by modding\\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\\n    // Convert it to a field element\\n    let mut v = 1;\\n    let mut high = 0 as Field;\\n    let mut low = 0 as Field;\\n\\n    for i in 0..16 {\\n        high = high + (bytes32[15 - i] as Field) * v;\\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\\n        v = v * 256;\\n    }\\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\\n    low + high * v\\n}\\n\\nfn lt_fallback(x: Field, y: Field) -> bool {\\n    if is_unconstrained() {\\n        unsafe {\\n            //@safety : unconstrained context\\n            field_less_than(x, y)\\n        }\\n    } else {\\n        let x_bytes: [u8; 32] = x.to_le_bytes();\\n        let y_bytes: [u8; 32] = y.to_le_bytes();\\n        let mut x_is_lt = false;\\n        let mut done = false;\\n        for i in 0..32 {\\n            if (!done) {\\n                let x_byte = x_bytes[32 - 1 - i] as u8;\\n                let y_byte = y_bytes[32 - 1 - i] as u8;\\n                let bytes_match = x_byte == y_byte;\\n                if !bytes_match {\\n                    x_is_lt = x_byte < y_byte;\\n                    done = true;\\n                }\\n            }\\n        }\\n        x_is_lt\\n    }\\n}\\n\\nmod tests {\\n    use super::field_less_than;\\n\\n    #[test]\\n    // docs:start:to_be_bits_example\\n    fn test_to_be_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_be_bits();\\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\\n    }\\n    // docs:end:to_be_bits_example\\n\\n    #[test]\\n    // docs:start:to_le_bits_example\\n    fn test_to_le_bits() {\\n        let field = 2;\\n        let bits: [u1; 8] = field.to_le_bits();\\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\\n    }\\n    // docs:end:to_le_bits_example\\n\\n    #[test]\\n    // docs:start:to_be_bytes_example\\n    fn test_to_be_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_be_bytes();\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_bytes_example\\n\\n    #[test]\\n    // docs:start:to_le_bytes_example\\n    fn test_to_le_bytes() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_le_bytes();\\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_bytes_example\\n\\n    #[test]\\n    // docs:start:to_be_radix_example\\n    fn test_to_be_radix() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_be_radix(256);\\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_be_radix_example\\n\\n    #[test]\\n    // docs:start:to_le_radix_example\\n    fn test_to_le_radix() {\\n        let field = 2;\\n        let bytes: [u8; 8] = field.to_le_radix(256);\\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\\n    }\\n    // docs:end:to_le_radix_example\\n\\n    #[test]\\n    unconstrained fn test_field_less_than() {\\n        assert(field_less_than(0, 1));\\n        assert(field_less_than(0, 0x100));\\n        assert(field_less_than(0x100, 0 - 1));\\n        assert(!field_less_than(0 - 1, 0));\\n    }\\n}\\n"},"21":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\\npub mod poseidon2;\\npub mod keccak;\\npub mod sha256;\\npub mod sha512;\\n\\nuse crate::default::Default;\\nuse crate::embedded_curve_ops::{\\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\\n};\\nuse crate::meta::derive_via;\\nuse crate::uint128::U128;\\n\\n// Kept for backwards compatibility\\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\\n\\n#[foreign(blake2s)]\\n// docs:start:blake2s\\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\\n// docs:end:blake2s\\n{}\\n\\n#[foreign(blake3)]\\n// docs:start:blake3\\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\\n// docs:end:blake3\\n{}\\n\\n// docs:start:pedersen_commitment\\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\\n    // docs:end:pedersen_commitment\\n    pedersen_commitment_with_separator(input, 0)\\n}\\n\\n#[inline_always]\\npub fn pedersen_commitment_with_separator<let N: u32>(\\n    input: [Field; N],\\n    separator: u32,\\n) -> EmbeddedCurvePoint {\\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\\n    for i in 0..N {\\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\\n        points[i] = from_field_unsafe(input[i]);\\n    }\\n    let generators = derive_generators(\\"DEFAULT_DOMAIN_SEPARATOR\\".as_bytes(), separator);\\n    multi_scalar_mul(generators, points)\\n}\\n\\n// docs:start:pedersen_hash\\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\\n// docs:end:pedersen_hash\\n{\\n    pedersen_hash_with_separator(input, 0)\\n}\\n\\n#[no_predicates]\\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\\n    let domain_generators: [EmbeddedCurvePoint; N] =\\n        derive_generators(\\"DEFAULT_DOMAIN_SEPARATOR\\".as_bytes(), separator);\\n\\n    for i in 0..N {\\n        scalars[i] = from_field_unsafe(input[i]);\\n        generators[i] = domain_generators[i];\\n    }\\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\\n\\n    let length_generator: [EmbeddedCurvePoint; 1] =\\n        derive_generators(\\"pedersen_hash_length\\".as_bytes(), 0);\\n    generators[N] = length_generator[0];\\n    multi_scalar_mul_array_return(generators, scalars)[0]\\n}\\n\\n#[field(bn254)]\\n#[inline_always]\\npub fn derive_generators<let N: u32, let M: u32>(\\n    domain_separator_bytes: [u8; M],\\n    starting_index: u32,\\n) -> [EmbeddedCurvePoint; N] {\\n    crate::assert_constant(domain_separator_bytes);\\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\\n    __derive_generators(domain_separator_bytes, starting_index)\\n}\\n\\n#[builtin(derive_pedersen_generators)]\\n#[field(bn254)]\\nfn __derive_generators<let N: u32, let M: u32>(\\n    domain_separator_bytes: [u8; M],\\n    starting_index: u32,\\n) -> [EmbeddedCurvePoint; N] {}\\n\\n#[field(bn254)]\\n// Same as from_field but:\\n// does not assert the limbs are 128 bits\\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\\n    let (xlo, xhi) = unsafe {\\n        //@safety : xlo and xhi decomposition is checked below\\n        crate::field::bn254::decompose_hint(scalar)\\n    };\\n    // Check that the decomposition is correct\\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\\n}\\n\\npub fn hash_to_field(inputs: [Field]) -> Field {\\n    let mut sum = 0;\\n\\n    for input in inputs {\\n        let input_bytes: [u8; 32] = input.to_le_bytes();\\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\\n    }\\n\\n    sum\\n}\\n\\n// docs:start:keccak256\\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\\n// docs:end:keccak256\\n{\\n    crate::hash::keccak::keccak256(input, message_size)\\n}\\n\\n#[foreign(poseidon2_permutation)]\\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\\n\\n// Generic hashing support.\\n// Partially ported and impacted by rust.\\n\\n// Hash trait shall be implemented per type.\\n#[derive_via(derive_hash)]\\npub trait Hash {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher;\\n}\\n\\n// docs:start:derive_hash\\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\\n    let name = quote { Hash };\\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\\n    crate::meta::make_trait_impl(\\n        s,\\n        name,\\n        signature,\\n        for_each_field,\\n        quote {},\\n        |fields| fields,\\n    )\\n}\\n// docs:end:derive_hash\\n\\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\\n// TODO: consider making the types generic here ([u8], [Field], etc.)\\npub trait Hasher {\\n    fn finish(self) -> Field;\\n\\n    fn write(&mut self, input: Field);\\n}\\n\\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\\npub trait BuildHasher<H>\\nwhere\\n    H: Hasher,\\n{\\n    fn build_hasher(self) -> H;\\n}\\n\\npub struct BuildHasherDefault<H>;\\n\\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\\nwhere\\n    H: Hasher + Default,\\n{\\n    fn build_hasher(_self: Self) -> H {\\n        H::default()\\n    }\\n}\\n\\nimpl<H> Default for BuildHasherDefault<H>\\nwhere\\n    H: Hasher + Default,\\n{\\n    fn default() -> Self {\\n        BuildHasherDefault {}\\n    }\\n}\\n\\nimpl Hash for Field {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self);\\n    }\\n}\\n\\nimpl Hash for u1 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for u8 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for u16 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for u32 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for u64 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for i8 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for i16 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for i32 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for i64 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for bool {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self as Field);\\n    }\\n}\\n\\nimpl Hash for () {\\n    fn hash<H>(_self: Self, _state: &mut H)\\n    where\\n        H: Hasher,\\n    {}\\n}\\n\\nimpl Hash for U128 {\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        H::write(state, self.lo as Field);\\n        H::write(state, self.hi as Field);\\n    }\\n}\\n\\nimpl<T, let N: u32> Hash for [T; N]\\nwhere\\n    T: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        for elem in self {\\n            elem.hash(state);\\n        }\\n    }\\n}\\n\\nimpl<T> Hash for [T]\\nwhere\\n    T: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self.len().hash(state);\\n        for elem in self {\\n            elem.hash(state);\\n        }\\n    }\\n}\\n\\nimpl<A, B> Hash for (A, B)\\nwhere\\n    A: Hash,\\n    B: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self.0.hash(state);\\n        self.1.hash(state);\\n    }\\n}\\n\\nimpl<A, B, C> Hash for (A, B, C)\\nwhere\\n    A: Hash,\\n    B: Hash,\\n    C: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self.0.hash(state);\\n        self.1.hash(state);\\n        self.2.hash(state);\\n    }\\n}\\n\\nimpl<A, B, C, D> Hash for (A, B, C, D)\\nwhere\\n    A: Hash,\\n    B: Hash,\\n    C: Hash,\\n    D: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self.0.hash(state);\\n        self.1.hash(state);\\n        self.2.hash(state);\\n        self.3.hash(state);\\n    }\\n}\\n\\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\\nwhere\\n    A: Hash,\\n    B: Hash,\\n    C: Hash,\\n    D: Hash,\\n    E: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self.0.hash(state);\\n        self.1.hash(state);\\n        self.2.hash(state);\\n        self.3.hash(state);\\n        self.4.hash(state);\\n    }\\n}\\n\\n// Some test vectors for Pedersen hash and Pedersen Commitment.\\n// They have been generated using the same functions so the tests are for now useless\\n// but they will be useful when we switch to Noir implementation.\\n#[test]\\nfn assert_pedersen() {\\n    assert_eq(\\n        pedersen_hash_with_separator([1], 1),\\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1], 1),\\n        EmbeddedCurvePoint {\\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\\n            is_infinite: false,\\n        },\\n    );\\n\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2], 2),\\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2], 2),\\n        EmbeddedCurvePoint {\\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3], 3),\\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3], 3),\\n        EmbeddedCurvePoint {\\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\\n        EmbeddedCurvePoint {\\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\\n        EmbeddedCurvePoint {\\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\\n        EmbeddedCurvePoint {\\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\\n        EmbeddedCurvePoint {\\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\\n        EmbeddedCurvePoint {\\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\\n        EmbeddedCurvePoint {\\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\\n            is_infinite: false,\\n        },\\n    );\\n    assert_eq(\\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\\n    );\\n    assert_eq(\\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\\n        EmbeddedCurvePoint {\\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\\n            is_infinite: false,\\n        },\\n    );\\n}\\n"},"26":{"path":"std/hash/poseidon2.nr","source":"use crate::default::Default;\\nuse crate::hash::Hasher;\\n\\ncomptime global RATE: u32 = 3;\\n\\npub struct Poseidon2 {\\n    cache: [Field; 3],\\n    state: [Field; 4],\\n    cache_size: u32,\\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\\n}\\n\\nimpl Poseidon2 {\\n    #[no_predicates]\\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\\n        Poseidon2::hash_internal(input, message_size, message_size != N)\\n    }\\n\\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\\n        let mut result =\\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\\n        result.state[RATE] = iv;\\n        result\\n    }\\n\\n    fn perform_duplex(&mut self) {\\n        // add the cache into sponge state\\n        for i in 0..RATE {\\n            // We effectively zero-pad the cache by only adding to the state\\n            // cache that is less than the specified `cache_size`\\n            if i < self.cache_size {\\n                self.state[i] += self.cache[i];\\n            }\\n        }\\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\\n    }\\n\\n    fn absorb(&mut self, input: Field) {\\n        assert(!self.squeeze_mode);\\n        if self.cache_size == RATE {\\n            // If we\'re absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else {\\n            // If we\'re absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    fn squeeze(&mut self) -> Field {\\n        assert(!self.squeeze_mode);\\n        // If we\'re in absorb mode, apply sponge permutation to compress the cache.\\n        self.perform_duplex();\\n        self.squeeze_mode = true;\\n\\n        // Pop one item off the top of the permutation and return it.\\n        self.state[0]\\n    }\\n\\n    fn hash_internal<let N: u32>(\\n        input: [Field; N],\\n        in_len: u32,\\n        is_variable_length: bool,\\n    ) -> Field {\\n        let two_pow_64 = 18446744073709551616;\\n        let iv: Field = (in_len as Field) * two_pow_64;\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..input.len() {\\n            if i < in_len {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if is_variable_length {\\n            sponge.absorb(1);\\n        }\\n        sponge.squeeze()\\n    }\\n}\\n\\npub struct Poseidon2Hasher {\\n    _state: [Field],\\n}\\n\\nimpl Hasher for Poseidon2Hasher {\\n    fn finish(self) -> Field {\\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\\n        let mut sponge = Poseidon2::new(iv);\\n        for i in 0..self._state.len() {\\n            sponge.absorb(self._state[i]);\\n        }\\n        sponge.squeeze()\\n    }\\n\\n    fn write(&mut self, input: Field) {\\n        self._state = self._state.push_back(input);\\n    }\\n}\\n\\nimpl Default for Poseidon2Hasher {\\n    fn default() -> Self {\\n        Poseidon2Hasher { _state: &[] }\\n    }\\n}\\n"},"51":{"path":"std/option.nr","source":"use crate::cmp::{Eq, Ord, Ordering};\\nuse crate::default::Default;\\nuse crate::hash::{Hash, Hasher};\\n\\npub struct Option<T> {\\n    _is_some: bool,\\n    _value: T,\\n}\\n\\nimpl<T> Option<T> {\\n    /// Constructs a None value\\n    pub fn none() -> Self {\\n        Self { _is_some: false, _value: crate::mem::zeroed() }\\n    }\\n\\n    /// Constructs a Some wrapper around the given value\\n    pub fn some(_value: T) -> Self {\\n        Self { _is_some: true, _value }\\n    }\\n\\n    /// True if this Option is None\\n    pub fn is_none(self) -> bool {\\n        !self._is_some\\n    }\\n\\n    /// True if this Option is Some\\n    pub fn is_some(self) -> bool {\\n        self._is_some\\n    }\\n\\n    /// Asserts `self.is_some()` and returns the wrapped value.\\n    pub fn unwrap(self) -> T {\\n        assert(self._is_some);\\n        self._value\\n    }\\n\\n    /// Returns the inner value without asserting `self.is_some()`\\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\\n    /// only that it will be of type `T`.\\n    pub fn unwrap_unchecked(self) -> T {\\n        self._value\\n    }\\n\\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\\n    pub fn unwrap_or(self, default: T) -> T {\\n        if self._is_some {\\n            self._value\\n        } else {\\n            default\\n        }\\n    }\\n\\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\\n    /// a default value.\\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\\n        if self._is_some {\\n            self._value\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\\n        assert(self.is_some(), message);\\n        self._value\\n    }\\n\\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\\n        if self._is_some {\\n            Option::some(f(self._value))\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            default\\n        }\\n    }\\n\\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    /// Returns None if self is None. Otherwise, this returns `other`.\\n    pub fn and(self, other: Self) -> Self {\\n        if self.is_none() {\\n            Option::none()\\n        } else {\\n            other\\n        }\\n    }\\n\\n    /// If self is None, this returns None. Otherwise, this calls the given function\\n    /// with the Some value contained within self, and returns the result of that call.\\n    ///\\n    /// In some languages this function is called `flat_map` or `bind`.\\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\\n        if self._is_some {\\n            f(self._value)\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// If self is Some, return self. Otherwise, return `other`.\\n    pub fn or(self, other: Self) -> Self {\\n        if self._is_some {\\n            self\\n        } else {\\n            other\\n        }\\n    }\\n\\n    /// If self is Some, return self. Otherwise, return `default()`.\\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\\n        if self._is_some {\\n            self\\n        } else {\\n            default()\\n        }\\n    }\\n\\n    // If only one of the two Options is Some, return that option.\\n    // Otherwise, if both options are Some or both are None, None is returned.\\n    pub fn xor(self, other: Self) -> Self {\\n        if self._is_some {\\n            if other._is_some {\\n                Option::none()\\n            } else {\\n                self\\n            }\\n        } else if other._is_some {\\n            other\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\\n    /// Otherwise, this returns `None`\\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\\n        if self._is_some {\\n            if predicate(self._value) {\\n                self\\n            } else {\\n                Option::none()\\n            }\\n        } else {\\n            Option::none()\\n        }\\n    }\\n\\n    /// Flattens an Option<Option<T>> into a Option<T>.\\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\\n        if option._is_some {\\n            option._value\\n        } else {\\n            Option::none()\\n        }\\n    }\\n}\\n\\nimpl<T> Default for Option<T> {\\n    fn default() -> Self {\\n        Option::none()\\n    }\\n}\\n\\nimpl<T> Eq for Option<T>\\nwhere\\n    T: Eq,\\n{\\n    fn eq(self, other: Self) -> bool {\\n        if self._is_some == other._is_some {\\n            if self._is_some {\\n                self._value == other._value\\n            } else {\\n                true\\n            }\\n        } else {\\n            false\\n        }\\n    }\\n}\\n\\nimpl<T> Hash for Option<T>\\nwhere\\n    T: Hash,\\n{\\n    fn hash<H>(self, state: &mut H)\\n    where\\n        H: Hasher,\\n    {\\n        self._is_some.hash(state);\\n        if self._is_some {\\n            self._value.hash(state);\\n        }\\n    }\\n}\\n\\n// For this impl we\'re declaring Option::none < Option::some\\nimpl<T> Ord for Option<T>\\nwhere\\n    T: Ord,\\n{\\n    fn cmp(self, other: Self) -> Ordering {\\n        if self._is_some {\\n            if other._is_some {\\n                self._value.cmp(other._value)\\n            } else {\\n                Ordering::greater()\\n            }\\n        } else if other._is_some {\\n            Ordering::less()\\n        } else {\\n            Ordering::equal()\\n        }\\n    }\\n}\\n"},"52":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\\n    assert(false, message);\\n    crate::mem::zeroed()\\n}\\n"},"62":{"path":"/home/john-play/Documents/joaolago1113/ZKRPS/zkrps/src/main.nr","source":"mod test;\\nuse dep::aztec::macros::aztec;\\n\\n#[aztec]\\ncontract EasyPrivateVoting {\\n    use dep::aztec::{\\n        keys::getters::get_public_keys,\\n        macros::{functions::{initializer, internal, private, public}, storage::storage},\\n    };\\n    use dep::aztec::prelude::{AztecAddress, Map, PublicImmutable, PublicMutable};\\n    #[storage]\\n    struct Storage<Context> {\\n        admin: PublicMutable<AztecAddress, Context>, // admin can end vote\\n        tally: Map<Field, PublicMutable<Field, Context>, Context>, // we will store candidate as key and number of votes as value\\n        vote_ended: PublicMutable<bool, Context>, // vote_ended is boolean\\n        active_at_block: PublicImmutable<u32, Context>, // when people can start voting\\n    }\\n\\n    #[public]\\n    #[initializer]\\n    // annotation to mark function as a constructor\\n    fn constructor(admin: AztecAddress) {\\n        storage.admin.write(admin);\\n        storage.vote_ended.write(false);\\n        storage.active_at_block.initialize(context.block_number() as u32);\\n    }\\n\\n    #[private]\\n    // annotation to mark function as private and expose private context\\n    fn cast_vote(candidate: Field) {\\n        let msg_sender_npk_m_hash = get_public_keys(context.msg_sender()).npk_m.hash();\\n\\n        let secret = context.request_nsk_app(msg_sender_npk_m_hash); // get secret key of caller of function\\n        let nullifier = std::hash::pedersen_hash([context.msg_sender().to_field(), secret]); // derive nullifier from sender and secret\\n        context.push_nullifier(nullifier);\\n        EasyPrivateVoting::at(context.this_address()).add_to_tally_public(candidate).enqueue(\\n            &mut context,\\n        );\\n    }\\n\\n    #[public]\\n    #[internal]\\n    fn add_to_tally_public(candidate: Field) {\\n        assert(storage.vote_ended.read() == false, \\"Vote has ended\\"); // assert that vote has not ended\\n        let new_tally = storage.tally.at(candidate).read() + 1;\\n        storage.tally.at(candidate).write(new_tally);\\n    }\\n\\n    #[public]\\n    fn end_vote() {\\n        assert(storage.admin.read().eq(context.msg_sender()), \\"Only admin can end votes\\"); // assert that caller is admin\\n        storage.vote_ended.write(true);\\n    }\\n    unconstrained fn get_vote(candidate: Field) -> pub Field {\\n        storage.tally.at(candidate).read()\\n    }\\n}\\n"},"69":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\\n/// allows the simulator to know how to respond to this future request.\\n///\\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\\npub fn pack_arguments(args: [Field]) {\\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\\n    // unpacking however the caller must check that the returned value is indeed the preimage.\\n    unsafe { pack_arguments_oracle_wrapper(args) };\\n}\\n\\n/// Same as `pack_arguments`, but using arrays instead of slices.\\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\\n    // unpacking however the caller must check that the returned value is indeed the preimage.\\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\\n}\\n\\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\\n    let _ = pack_arguments_oracle(args);\\n}\\n\\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\\n    let _ = pack_arguments_array_oracle(args);\\n}\\n\\n#[oracle(packArguments)]\\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\\n\\n#[oracle(packArgumentsArray)]\\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\\n"},"72":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\\n\\nuse dep::protocol_types::{\\n    address::AztecAddress,\\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\\n};\\n\\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\\npub fn notify_created_note<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    serialized_note: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\\n    unsafe {\\n        notify_created_note_oracle_wrapper(\\n            storage_slot,\\n            note_type_id,\\n            serialized_note,\\n            note_hash,\\n            counter,\\n        )\\n    };\\n}\\n\\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\\n/// actual block.\\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\\n}\\n\\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\\n    storage_slot: Field,\\n    note_type_id: Field,\\n    serialized_note: [Field; N],\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_created_note_oracle(\\n        storage_slot,\\n        note_type_id,\\n        serialized_note,\\n        note_hash,\\n        counter,\\n    );\\n}\\n\\n#[oracle(notifyCreatedNote)]\\nunconstrained fn notify_created_note_oracle<let N: u32>(\\n    _storage_slot: Field,\\n    _note_type_id: Field,\\n    _serialized_note: [Field; N],\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\nunconstrained fn notify_nullified_note_oracle_wrapper(\\n    nullifier: Field,\\n    note_hash: Field,\\n    counter: u32,\\n) {\\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\\n}\\n\\n#[oracle(notifyNullifiedNote)]\\nunconstrained fn notify_nullified_note_oracle(\\n    _nullifier: Field,\\n    _note_hash: Field,\\n    _counter: u32,\\n) -> Field {}\\n\\n#[oracle(getNotes)]\\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\\n    _storage_slot: Field,\\n    _num_selects: u8,\\n    _select_by_indexes: [u8; N],\\n    _select_by_offsets: [u8; N],\\n    _select_by_lengths: [u8; N],\\n    _select_values: [Field; N],\\n    _select_comparators: [u8; N],\\n    _sort_by_indexes: [u8; N],\\n    _sort_by_offsets: [u8; N],\\n    _sort_by_lengths: [u8; N],\\n    _sort_order: [u8; N],\\n    _limit: u32,\\n    _offset: u32,\\n    _status: u8,\\n    _return_size: u32,\\n    _placeholder_fields: [Field; S],\\n) -> [Field; S] {}\\n\\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; N],\\n    select_by_offsets: [u8; N],\\n    select_by_lengths: [u8; N],\\n    select_values: [Field; N],\\n    select_comparators: [u8; N],\\n    sort_by_indexes: [u8; N],\\n    sort_by_offsets: [u8; N],\\n    sort_by_lengths: [u8; N],\\n    sort_order: [u8; N],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_fields: [Field; S],\\n) -> [Field; S] {\\n    let return_size = placeholder_fields.len() as u32;\\n    get_notes_oracle(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        return_size,\\n        placeholder_fields,\\n    )\\n}\\n\\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\\n    storage_slot: Field,\\n    num_selects: u8,\\n    select_by_indexes: [u8; M],\\n    select_by_offsets: [u8; M],\\n    select_by_lengths: [u8; M],\\n    select_values: [Field; M],\\n    select_comparators: [u8; M],\\n    sort_by_indexes: [u8; M],\\n    sort_by_offsets: [u8; M],\\n    sort_by_lengths: [u8; M],\\n    sort_order: [u8; M],\\n    limit: u32,\\n    offset: u32,\\n    status: u8,\\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\\n) -> [Option<Note>; S]\\nwhere\\n    Note: NoteInterface<N>,\\n{\\n    sync_notes_oracle_wrapper();\\n    let fields = get_notes_oracle_wrapper(\\n        storage_slot,\\n        num_selects,\\n        select_by_indexes,\\n        select_by_offsets,\\n        select_by_lengths,\\n        select_values,\\n        select_comparators,\\n        sort_by_indexes,\\n        sort_by_offsets,\\n        sort_by_lengths,\\n        sort_order,\\n        limit,\\n        offset,\\n        status,\\n        placeholder_fields,\\n    );\\n    let num_notes = fields[0] as u32;\\n    let contract_address = AztecAddress::from_field(fields[1]);\\n    for i in 0..placeholder_opt_notes.len() {\\n        if i < num_notes {\\n            // lengths named as per typescript.\\n            let return_header_length: u32 = 2; // num_notes & contract_address.\\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\\n\\n            let nonce = fields[read_offset];\\n            let note_hash_counter = fields[read_offset + 1] as u32;\\n            let note_content = array::subarray(fields, read_offset + 2);\\n\\n            let mut note = Note::deserialize_content(note_content);\\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\\n\\n            placeholder_opt_notes[i] = Option::some(note);\\n        };\\n    }\\n    placeholder_opt_notes\\n}\\n\\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\\n    check_nullifier_exists_oracle(inner_nullifier) == 1\\n}\\n\\n#[oracle(checkNullifierExists)]\\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\\n\\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\\n}\\n\\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\\n/// Includes the last known index used to send a note tagged with this secret.\\n/// For this to work, PXE must know the ivsk_m of the sender.\\n/// For the recipient\'s side, only the address is needed.\\npub unconstrained fn get_indexed_tagging_secret_as_sender(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) -> IndexedTaggingSecret {\\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\\n    IndexedTaggingSecret::deserialize(result)\\n}\\n\\n#[oracle(getIndexedTaggingSecretAsSender)]\\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\\n\\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\\n/// future notes get a different tag and can be discovered by the recipient.\\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\\n/// that are not found by the recipient.\\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\\n    unsafe {\\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\\n    }\\n}\\n\\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\\n    sender: AztecAddress,\\n    recipient: AztecAddress,\\n) {\\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\\n}\\n\\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\\n    _sender: AztecAddress,\\n    _recipient: AztecAddress,\\n) {}\\n\\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\\n/// for later querying via the `get_notes` oracle.\\npub fn sync_notes() {\\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\\n    unsafe {\\n        sync_notes_oracle_wrapper();\\n    }\\n}\\n\\nunconstrained fn sync_notes_oracle_wrapper() {\\n    sync_notes_oracle();\\n}\\n\\n#[oracle(syncNotes)]\\nunconstrained fn sync_notes_oracle() {}\\n"},"74":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{\\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\\n};\\n\\n#[oracle(getKeyValidationRequest)]\\nunconstrained fn get_key_validation_request_oracle(\\n    _pk_m_hash: Field,\\n    _key_index: Field,\\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\\n\\nunconstrained fn get_key_validation_request_internal(\\n    npk_m_hash: Field,\\n    key_index: Field,\\n) -> KeyValidationRequest {\\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\\n    KeyValidationRequest::deserialize(result)\\n}\\n\\npub unconstrained fn get_key_validation_request(\\n    pk_m_hash: Field,\\n    key_index: Field,\\n) -> KeyValidationRequest {\\n    get_key_validation_request_internal(pk_m_hash, key_index)\\n}\\n"},"78":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\\n\\n#[oracle(storageRead)]\\nunconstrained fn storage_read_oracle<let N: u32>(\\n    address: Field,\\n    storage_slot: Field,\\n    block_number: Field,\\n    length: Field,\\n) -> [Field; N] {}\\n\\npub unconstrained fn raw_storage_read<let N: u32>(\\n    address: AztecAddress,\\n    storage_slot: Field,\\n    block_number: u32,\\n) -> [Field; N] {\\n    storage_read_oracle(\\n        address.to_field(),\\n        storage_slot,\\n        block_number as Field,\\n        N as Field,\\n    )\\n}\\n\\npub unconstrained fn storage_read<T, let N: u32>(\\n    address: AztecAddress,\\n    storage_slot: Field,\\n    block_number: u32,\\n) -> T\\nwhere\\n    T: Deserialize<N>,\\n{\\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\\n}\\n\\nmod tests {\\n    use crate::oracle::storage::{raw_storage_read, storage_read};\\n    use dep::protocol_types::address::AztecAddress;\\n\\n    use crate::test::mocks::mock_struct::MockStruct;\\n    use std::test::OracleMock;\\n\\n    global address: AztecAddress = AztecAddress::from_field(29);\\n    global slot: Field = 7;\\n    global block_number: u32 = 17;\\n\\n    #[test]\\n    unconstrained fn test_raw_storage_read() {\\n        let written = MockStruct { a: 13, b: 42 };\\n\\n        let _ = OracleMock::mock(\\"storageRead\\").returns(written.serialize());\\n\\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\\n        assert_eq(read[0], 13);\\n        assert_eq(read[1], 42);\\n    }\\n\\n    #[test]\\n    unconstrained fn test_storage_read() {\\n        let written = MockStruct { a: 13, b: 42 };\\n\\n        let _ = OracleMock::mock(\\"storageRead\\").returns(written.serialize());\\n\\n        let read: MockStruct = storage_read(address, slot, block_number);\\n        assert_eq(read.a, 13);\\n        assert_eq(read.b, 42);\\n    }\\n}\\n"},"79":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use dep::protocol_types::{\\n    address::{AztecAddress, PartialAddress},\\n    point::Point,\\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\\n};\\n\\n#[oracle(getPublicKeysAndPartialAddress)]\\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\\n\\npub unconstrained fn get_public_keys_and_partial_address(\\n    address: AztecAddress,\\n) -> (PublicKeys, PartialAddress) {\\n    let result = get_public_keys_and_partial_address_oracle(address);\\n\\n    let keys = PublicKeys {\\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\\n        ivpk_m: IvpkM {\\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\\n        },\\n        ovpk_m: OvpkM {\\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\\n        },\\n        tpk_m: TpkM {\\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\\n        },\\n    };\\n\\n    let partial_address = PartialAddress::from_field(result[12]);\\n\\n    (keys, partial_address)\\n}\\n"},"80":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\\n    contract_instance::ContractInstance,\\n};\\n\\n// NOTE: this is for use in private only\\n#[oracle(getContractInstance)]\\nunconstrained fn get_contract_instance_oracle(\\n    _address: AztecAddress,\\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\\n\\n// NOTE: this is for use in private only\\nunconstrained fn get_contract_instance_internal(\\n    address: AztecAddress,\\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\\n    get_contract_instance_oracle(address)\\n}\\n\\n// NOTE: this is for use in private only\\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\\n    let instance =\\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\\n    // get the expected address we validate the entire struct.\\n    assert_eq(instance.to_address(), address);\\n\\n    instance\\n}\\n\\n// These oracles each return a ContractInstance member\\n// plus a boolean indicating whether the instance was found.\\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\\nunconstrained fn get_contract_instance_deployer_oracle_avm(\\n    _address: AztecAddress,\\n) -> (Field, bool) {}\\n#[oracle(avmOpcodeGetContractInstanceClassId)]\\nunconstrained fn get_contract_instance_class_id_oracle_avm(\\n    _address: AztecAddress,\\n) -> (Field, bool) {}\\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\\n    _address: AztecAddress,\\n) -> (Field, bool) {}\\n\\npub unconstrained fn get_contract_instance_deployer_internal_avm(\\n    address: AztecAddress,\\n) -> (Field, bool) {\\n    get_contract_instance_deployer_oracle_avm(address)\\n}\\npub unconstrained fn get_contract_instance_class_id_internal_avm(\\n    address: AztecAddress,\\n) -> (Field, bool) {\\n    get_contract_instance_class_id_oracle_avm(address)\\n}\\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\\n    address: AztecAddress,\\n) -> (Field, bool) {\\n    get_contract_instance_initialization_hash_oracle_avm(address)\\n}\\n\\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\\n    if exists {\\n        Option::some(AztecAddress::from_field(member))\\n    } else {\\n        Option::none()\\n    }\\n}\\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\\n    if exists {\\n        Option::some(ContractClassId::from_field(member))\\n    } else {\\n        Option::none()\\n    }\\n}\\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\\n    if exists {\\n        Option::some(member)\\n    } else {\\n        Option::none()\\n    }\\n}\\n"},"84":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\\n\\n#[oracle(enqueuePublicFunctionCall)]\\nunconstrained fn enqueue_public_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> Field {}\\n\\npub unconstrained fn enqueue_public_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> Field {\\n    enqueue_public_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n    )\\n}\\n\\n#[oracle(setPublicTeardownFunctionCall)]\\nunconstrained fn set_public_teardown_function_call_oracle(\\n    _contract_address: AztecAddress,\\n    _function_selector: FunctionSelector,\\n    _args_hash: Field,\\n    _side_effect_counter: u32,\\n    _is_static_call: bool,\\n) -> Field {}\\n\\npub unconstrained fn set_public_teardown_function_call_internal(\\n    contract_address: AztecAddress,\\n    function_selector: FunctionSelector,\\n    args_hash: Field,\\n    side_effect_counter: u32,\\n    is_static_call: bool,\\n) -> Field {\\n    set_public_teardown_function_call_oracle(\\n        contract_address,\\n        function_selector,\\n        args_hash,\\n        side_effect_counter,\\n        is_static_call,\\n    )\\n}\\n\\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\\n}\\n\\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\\n}\\n\\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\\n"},"85":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\\n\\n#[oracle(getContractAddress)]\\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\\n\\n#[oracle(getBlockNumber)]\\nunconstrained fn get_block_number_oracle() -> u32 {}\\n\\n#[oracle(getChainId)]\\nunconstrained fn get_chain_id_oracle() -> Field {}\\n\\n#[oracle(getVersion)]\\nunconstrained fn get_version_oracle() -> Field {}\\n\\npub unconstrained fn get_contract_address() -> AztecAddress {\\n    get_contract_address_oracle()\\n}\\n\\npub unconstrained fn get_block_number() -> u32 {\\n    get_block_number_oracle()\\n}\\n\\npub unconstrained fn get_chain_id() -> Field {\\n    get_chain_id_oracle()\\n}\\n\\npub unconstrained fn get_version() -> Field {\\n    get_version_oracle()\\n}\\n"},"105":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\\nuse crate::state_vars::storage::Storage;\\nuse dep::protocol_types::traits::{Deserialize, Serialize};\\n\\n// docs:start:public_mutable_struct\\npub struct PublicMutable<T, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n}\\n// docs:end:public_mutable_struct\\n\\nimpl<T, Context, let N: u32> Storage<T, N> for PublicMutable<T, Context>\\nwhere\\n    T: Serialize<N> + Deserialize<N>,\\n{}\\n\\nimpl<T, Context> PublicMutable<T, Context> {\\n    // docs:start:public_mutable_struct_new\\n    pub fn new(\\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\\n        context: Context,\\n        storage_slot: Field,\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        PublicMutable { context, storage_slot }\\n    }\\n    // docs:end:public_mutable_struct_new\\n}\\n\\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext>\\nwhere\\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\\n{\\n    // docs:start:public_mutable_struct_read\\n    pub fn read(self) -> T {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n    // docs:end:public_mutable_struct_read\\n\\n    // docs:start:public_mutable_struct_write\\n    pub fn write(self, value: T) {\\n        self.context.storage_write(self.storage_slot, value);\\n    }\\n    // docs:end:public_mutable_struct_write\\n}\\n\\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext>\\nwhere\\n    T: Deserialize<T_SERIALIZED_LEN>,\\n{\\n    pub unconstrained fn read(self) -> T {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n}\\n"},"115":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr","source":"use crate::{\\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\\n    state_vars::storage::Storage,\\n};\\nuse dep::protocol_types::{\\n    constants::INITIALIZATION_SLOT_SEPARATOR,\\n    traits::{Deserialize, Serialize},\\n};\\n\\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\\n/// contexts.\\n// docs:start:public_immutable_struct\\npub struct PublicImmutable<T, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n}\\n// docs:end:public_immutable_struct\\n\\nimpl<T, Context, let N: u32> Storage<T, N> for PublicImmutable<T, Context>\\nwhere\\n    T: Serialize<N> + Deserialize<N>,\\n{}\\n\\nimpl<T, Context> PublicImmutable<T, Context> {\\n    // docs:start:public_immutable_struct_new\\n    pub fn new(\\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\\n        context: Context,\\n        storage_slot: Field,\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        PublicImmutable { context, storage_slot }\\n    }\\n    // docs:end:public_immutable_struct_new\\n}\\n\\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PublicContext>\\nwhere\\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\\n{\\n    // docs:start:public_immutable_struct_write\\n    pub fn initialize(self, value: T) {\\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\\n        let init_field: Field = self.context.storage_read(initialization_slot);\\n        assert(init_field == 0, \\"PublicImmutable already initialized\\");\\n\\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\\n        self.context.storage_write(initialization_slot, 0xdead);\\n        self.context.storage_write(self.storage_slot, value);\\n    }\\n    // docs:end:public_immutable_struct_write\\n\\n    // Note that we don\'t access the context, but we do call oracles that are only available in public\\n    // docs:start:public_immutable_struct_read\\n    pub fn read(self) -> T {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n    // docs:end:public_immutable_struct_read\\n}\\n\\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\\nwhere\\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\\n{\\n    pub unconstrained fn read(self) -> T {\\n        self.context.storage_read(self.storage_slot)\\n    }\\n}\\n\\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\\nwhere\\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\\n{\\n    pub fn read(self) -> T {\\n        let header = self.context.get_block_header();\\n        let mut fields = [0; T_SERIALIZED_LEN];\\n\\n        for i in 0..fields.len() {\\n            fields[i] = header.public_storage_historical_read(\\n                self.storage_slot + i as Field,\\n                (*self.context).this_address(),\\n            );\\n        }\\n        T::deserialize(fields)\\n    }\\n}\\n"},"119":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use crate::state_vars::storage::Storage;\\nuse dep::protocol_types::{\\n    storage::map::derive_storage_slot_in_map,\\n    traits::{Deserialize, Serialize, ToField},\\n};\\n\\n// docs:start:map\\npub struct Map<K, V, Context> {\\n    context: Context,\\n    storage_slot: Field,\\n    state_var_constructor: fn(Context, Field) -> V,\\n}\\n// docs:end:map\\n\\nimpl<K, T, Context, let N: u32> Storage<T, N> for Map<K, T, Context>\\nwhere\\n    T: Serialize<N> + Deserialize<N>,\\n{}\\n\\nimpl<K, V, Context> Map<K, V, Context> {\\n    // docs:start:new\\n    pub fn new(\\n        context: Context,\\n        storage_slot: Field,\\n        state_var_constructor: fn(Context, Field) -> V,\\n    ) -> Self {\\n        assert(storage_slot != 0, \\"Storage slot 0 not allowed. Storage slots must start from 1.\\");\\n        Map { context, storage_slot, state_var_constructor }\\n    }\\n    // docs:end:new\\n\\n    // docs:start:at\\n    pub fn at(self, key: K) -> V\\n    where\\n        K: ToField,\\n    {\\n        // TODO(#1204): use a generator index for the storage slot\\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\\n\\n        let state_var_constructor = self.state_var_constructor;\\n        state_var_constructor(self.context, derived_storage_slot)\\n    }\\n    // docs:end:at\\n}\\n"},"121":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\\nuse dep::protocol_types::{\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\\n        GENERATOR_INDEX__SECRET_HASH,\\n    },\\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\\n    point::Point,\\n    traits::Hash,\\n};\\n\\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\\n\\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\\n}\\n\\npub fn compute_secret_hash(secret: Field) -> Field {\\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\\n}\\n\\npub fn compute_unencrypted_log_hash<let N: u32>(\\n    contract_address: AztecAddress,\\n    log: [u8; N],\\n) -> Field {\\n    let mut hash_bytes = [0; N + 36];\\n    // Address is converted to 32 bytes in ts\\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\\n    for i in 0..32 {\\n        hash_bytes[i] = address_bytes[i];\\n    }\\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\\n    for i in 0..4 {\\n        hash_bytes[32 + i] = len_bytes[i];\\n    }\\n    for i in 0..N {\\n        hash_bytes[36 + i] = log[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\npub fn compute_l1_to_l2_message_hash(\\n    sender: EthAddress,\\n    chain_id: Field,\\n    recipient: AztecAddress,\\n    version: Field,\\n    content: Field,\\n    secret_hash: Field,\\n    leaf_index: Field,\\n) -> Field {\\n    let mut hash_bytes = [0 as u8; 224];\\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\\n    let version_bytes: [u8; 32] = version.to_be_bytes();\\n    let content_bytes: [u8; 32] = content.to_be_bytes();\\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\\n\\n    for i in 0..32 {\\n        hash_bytes[i] = sender_bytes[i];\\n        hash_bytes[i + 32] = chain_id_bytes[i];\\n        hash_bytes[i + 64] = recipient_bytes[i];\\n        hash_bytes[i + 96] = version_bytes[i];\\n        hash_bytes[i + 128] = content_bytes[i];\\n        hash_bytes[i + 160] = secret_hash_bytes[i];\\n        hash_bytes[i + 192] = leaf_index_bytes[i];\\n    }\\n\\n    sha256_to_field(hash_bytes)\\n}\\n\\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\\n}\\n\\npub struct ArgsHasher {\\n    pub fields: [Field],\\n}\\n\\nimpl Hash for ArgsHasher {\\n    fn hash(self) -> Field {\\n        hash_args(self.fields)\\n    }\\n}\\n\\nimpl ArgsHasher {\\n    pub fn new() -> Self {\\n        Self { fields: [] }\\n    }\\n\\n    pub fn add(&mut self, field: Field) {\\n        self.fields = self.fields.push_back(field);\\n    }\\n\\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\\n        for i in 0..N {\\n            self.fields = self.fields.push_back(fields[i]);\\n        }\\n    }\\n}\\n\\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\npub fn hash_args(args: [Field]) -> Field {\\n    if args.len() == 0 {\\n        0\\n    } else {\\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\\n    }\\n}\\n\\n#[test]\\nunconstrained fn compute_var_args_hash() {\\n    let mut input = ArgsHasher::new();\\n    for i in 0..100 {\\n        input.add(i as Field);\\n    }\\n    let hash = input.hash();\\n    dep::std::println(hash);\\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\\n}\\n\\n#[test]\\nunconstrained fn compute_unenc_log_hash_array() {\\n    let contract_address = AztecAddress::from_field(\\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\\n    );\\n    let log = [\\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\\n    ];\\n    let serialized_log = arr_to_be_bytes_arr(log);\\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\\n}\\n\\n#[test]\\nunconstrained fn compute_unenc_log_hash_addr() {\\n    let contract_address = AztecAddress::from_field(\\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\\n    );\\n    let log = AztecAddress::from_field(\\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\\n    );\\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\\n}\\n\\n#[test]\\nunconstrained fn compute_unenc_log_hash_str() {\\n    let contract_address = AztecAddress::from_field(\\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\\n    );\\n    let log = \\"dummy\\";\\n    let serialized_log = str_to_be_bytes_arr(log);\\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\\n}\\n\\n#[test]\\nunconstrained fn compute_unenc_log_hash_longer_str() {\\n    let contract_address = AztecAddress::from_field(\\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\\n    );\\n    let log = \\"Hello this is a string\\";\\n    let serialized_log = str_to_be_bytes_arr(log);\\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\\n}\\n"},"143":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress,\\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\\n};\\n\\nuse crate::{\\n    context::{PrivateContext, PublicContext},\\n    oracle::get_contract_instance::{\\n        get_contract_instance, get_contract_instance_deployer_avm,\\n        get_contract_instance_initialization_hash_avm,\\n    },\\n};\\n\\npub fn mark_as_initialized_public(context: &mut PublicContext) {\\n    let init_nullifier =\\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\\n    context.push_nullifier(init_nullifier);\\n}\\n\\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\\n    let init_nullifier =\\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\\n    context.push_nullifier(init_nullifier);\\n}\\n\\npub fn assert_is_initialized_public(context: &mut PublicContext) {\\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \\"Not initialized\\");\\n}\\n\\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\\n    context.push_nullifier_read_request(init_nullifier);\\n}\\n\\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\\n    address.to_field()\\n}\\n\\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\\n    let address = context.this_address();\\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\\n    assert(initialization_hash == expected_init, \\"Initialization hash does not match\\");\\n    assert(\\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\\n        \\"Initializer address is not the contract deployer\\",\\n    );\\n}\\n\\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\\n    let address = context.this_address();\\n    let instance = get_contract_instance(address);\\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\\n    assert(instance.initialization_hash == expected_init, \\"Initialization hash does not match\\");\\n    assert(\\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\\n        \\"Initializer address is not the contract deployer\\",\\n    );\\n}\\n\\npub fn compute_initialization_hash(\\n    init_selector: FunctionSelector,\\n    init_args_hash: Field,\\n) -> Field {\\n    poseidon2_hash_with_separator(\\n        [init_selector.to_field(), init_args_hash],\\n        GENERATOR_INDEX__CONSTRUCTOR,\\n    )\\n}\\n"},"147":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use crate::oracle::{\\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\\n    storage::storage_read,\\n};\\nuse dep::protocol_types::{address::AztecAddress, traits::Deserialize};\\n\\npub struct UnconstrainedContext {\\n    block_number: u32,\\n    contract_address: AztecAddress,\\n    version: Field,\\n    chain_id: Field,\\n}\\n\\nimpl UnconstrainedContext {\\n    pub unconstrained fn new() -> Self {\\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\\n        // not even be accessed. However any performance gains are minimal, and we\'d rather fail early if a user\\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\\n        // available.\\n        let block_number = get_block_number();\\n        let contract_address = get_contract_address();\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\\n        let block_number = get_block_number();\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\\n        let chain_id = get_chain_id();\\n        let version = get_version();\\n        Self { block_number, contract_address, version, chain_id }\\n    }\\n\\n    pub fn block_number(self) -> u32 {\\n        self.block_number\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.contract_address\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.version\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.chain_id\\n    }\\n\\n    pub unconstrained fn raw_storage_read<let N: u32>(\\n        self: Self,\\n        storage_slot: Field,\\n    ) -> [Field; N] {\\n        storage_read(self.this_address(), storage_slot, self.block_number())\\n    }\\n\\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\\n    where\\n        T: Deserialize<N>,\\n    {\\n        T::deserialize(self.raw_storage_read(storage_slot))\\n    }\\n}\\n"},"149":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::context::gas::GasOpts;\\nuse crate::hash::{\\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\\n};\\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\\nuse dep::protocol_types::traits::{Deserialize, Empty, Serialize};\\n\\npub struct PublicContext {\\n    pub args_hash: Option<Field>,\\n    pub compute_args_hash: fn() -> Field,\\n}\\n\\nimpl PublicContext {\\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\\n        PublicContext { args_hash: Option::none(), compute_args_hash }\\n    }\\n\\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\\n    where\\n        T: Serialize<N>,\\n    {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_unencrypted_log(Serialize::serialize(log).as_slice()) };\\n    }\\n\\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\\n    }\\n\\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\\n    }\\n\\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\\n    }\\n\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        let secret_hash = compute_secret_hash(secret);\\n        let message_hash = compute_l1_to_l2_message_hash(\\n            sender,\\n            self.chain_id(),\\n            /*recipient=*/\\n            self.this_address(),\\n            self.version(),\\n            content,\\n            secret_hash,\\n            leaf_index,\\n        );\\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\\n\\n        assert(\\n            !self.nullifier_exists(nullifier, self.this_address()),\\n            \\"L1-to-L2 message is already nullified\\",\\n        );\\n        assert(\\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\\n            \\"Tried to consume nonexistent L1-to-L2 message\\",\\n        );\\n\\n        self.push_nullifier(nullifier);\\n    }\\n\\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe { send_l2_to_l1_msg(recipient, content) };\\n    }\\n\\n    pub unconstrained fn call_public_function(\\n        _self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field],\\n        gas_opts: GasOpts,\\n    ) -> [Field] {\\n        let args = args.push_front(function_selector.to_field());\\n        let success = call(gas_for_call(gas_opts), contract_address, args);\\n\\n        let result_data = returndata_copy(0, returndata_size());\\n        if !success {\\n            // Rethrow the revert data.\\n            avm_revert(result_data);\\n        }\\n        result_data\\n    }\\n\\n    pub unconstrained fn static_call_public_function(\\n        _self: &mut Self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field],\\n        gas_opts: GasOpts,\\n    ) -> [Field] {\\n        let args = args.push_front(function_selector.to_field());\\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\\n\\n        let result_data = returndata_copy(0, returndata_size());\\n        if !success {\\n            // Rethrow the revert data.\\n            avm_revert(result_data);\\n        }\\n        result_data\\n    }\\n\\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_note_hash(note_hash) };\\n    }\\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe { emit_nullifier(nullifier) };\\n    }\\n\\n    pub fn this_address(_self: Self) -> AztecAddress {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            address()\\n        }\\n    }\\n    pub fn msg_sender(_self: Self) -> AztecAddress {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            sender()\\n        }\\n    }\\n    pub fn selector(_self: Self) -> FunctionSelector {\\n        // The selector is the first element of the calldata when calling a public function through dispatch.\\n        // AVM opcodes are constrained by the AVM itself.\\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\\n        FunctionSelector::from_field(raw_selector[0])\\n    }\\n    pub fn get_args_hash(mut self) -> Field {\\n        if !self.args_hash.is_some() {\\n            self.args_hash = Option::some((self.compute_args_hash)());\\n        }\\n\\n        self.args_hash.unwrap_unchecked()\\n    }\\n    pub fn transaction_fee(_self: Self) -> Field {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            transaction_fee()\\n        }\\n    }\\n\\n    pub fn chain_id(_self: Self) -> Field {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            chain_id()\\n        }\\n    }\\n    pub fn version(_self: Self) -> Field {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            version()\\n        }\\n    }\\n    pub fn block_number(_self: Self) -> Field {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            block_number()\\n        }\\n    }\\n    pub fn timestamp(_self: Self) -> u64 {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            timestamp()\\n        }\\n    }\\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            fee_per_l2_gas()\\n        }\\n    }\\n    pub fn fee_per_da_gas(_self: Self) -> Field {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            fee_per_da_gas()\\n        }\\n    }\\n\\n    pub fn l2_gas_left(_self: Self) -> Field {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            l2_gas_left()\\n        }\\n    }\\n    pub fn da_gas_left(_self: Self) -> Field {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe {\\n            da_gas_left()\\n        }\\n    }\\n    pub fn is_static_call(_self: Self) -> bool {\\n        // AVM opcodes are constrained by the AVM itself\\n        unsafe { is_static_call() } == 1\\n    }\\n\\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\\n        let mut out = [0; N];\\n        for i in 0..N {\\n            // AVM opcodes are constrained by the AVM itself\\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\\n        }\\n        out\\n    }\\n\\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\\n    where\\n        T: Deserialize<N>,\\n    {\\n        T::deserialize(self.raw_storage_read(storage_slot))\\n    }\\n\\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\\n        for i in 0..N {\\n            // AVM opcodes are constrained by the AVM itself\\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\\n        }\\n    }\\n\\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\\n    where\\n        T: Serialize<N>,\\n    {\\n        self.raw_storage_write(storage_slot, value.serialize());\\n    }\\n}\\n\\n// Helper functions\\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\\n    // It\'s ok to use the max possible gas here, because the gas will be\\n    // capped by the gas left in the (STATIC)CALL instruction.\\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\\n}\\n\\n// Unconstrained opcode wrappers (do not use directly).\\nunconstrained fn address() -> AztecAddress {\\n    address_opcode()\\n}\\nunconstrained fn sender() -> AztecAddress {\\n    sender_opcode()\\n}\\nunconstrained fn transaction_fee() -> Field {\\n    transaction_fee_opcode()\\n}\\nunconstrained fn chain_id() -> Field {\\n    chain_id_opcode()\\n}\\nunconstrained fn version() -> Field {\\n    version_opcode()\\n}\\nunconstrained fn block_number() -> Field {\\n    block_number_opcode()\\n}\\nunconstrained fn timestamp() -> u64 {\\n    timestamp_opcode()\\n}\\nunconstrained fn fee_per_l2_gas() -> Field {\\n    fee_per_l2_gas_opcode()\\n}\\nunconstrained fn fee_per_da_gas() -> Field {\\n    fee_per_da_gas_opcode()\\n}\\nunconstrained fn l2_gas_left() -> Field {\\n    l2_gas_left_opcode()\\n}\\nunconstrained fn da_gas_left() -> Field {\\n    da_gas_left_opcode()\\n}\\nunconstrained fn is_static_call() -> Field {\\n    is_static_call_opcode()\\n}\\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\\n    note_hash_exists_opcode(note_hash, leaf_index)\\n}\\nunconstrained fn emit_note_hash(note_hash: Field) {\\n    emit_note_hash_opcode(note_hash)\\n}\\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\\n    nullifier_exists_opcode(nullifier, address)\\n}\\nunconstrained fn emit_nullifier(nullifier: Field) {\\n    emit_nullifier_opcode(nullifier)\\n}\\nunconstrained fn emit_unencrypted_log(message: [Field]) {\\n    emit_unencrypted_log_opcode(message)\\n}\\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\\n}\\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\\n    send_l2_to_l1_msg_opcode(recipient, content)\\n}\\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\\n    call_opcode(gas, address, args)\\n}\\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\\n    call_static_opcode(gas, address, args)\\n}\\n\\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\\n    calldata_copy_opcode(cdoffset, copy_size)\\n}\\n\\nunconstrained fn returndata_size() -> u32 {\\n    returndata_size_opcode()\\n}\\n\\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\\n    returndata_copy_opcode(rdoffset, copy_size)\\n}\\n\\npub unconstrained fn avm_return(returndata: [Field]) {\\n    return_opcode(returndata)\\n}\\n\\n// This opcode reverts using the exact data given. In general it should only be used\\n// to do rethrows, where the revert data is the same as the original revert data.\\n// For normal reverts, use Noir\'s `assert` which, on top of reverting, will also add\\n// an error selector to the revert data.\\nunconstrained fn avm_revert(revertdata: [Field]) {\\n    revert_opcode(revertdata)\\n}\\n\\nunconstrained fn storage_read(storage_slot: Field) -> Field {\\n    storage_read_opcode(storage_slot)\\n}\\n\\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\\n    storage_write_opcode(storage_slot, value);\\n}\\n\\nimpl Empty for PublicContext {\\n    fn empty() -> Self {\\n        PublicContext::new(|| 0)\\n    }\\n}\\n\\n// AVM oracles (opcodes) follow, do not use directly.\\n#[oracle(avmOpcodeAddress)]\\nunconstrained fn address_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodeSender)]\\nunconstrained fn sender_opcode() -> AztecAddress {}\\n\\n#[oracle(avmOpcodeTransactionFee)]\\nunconstrained fn transaction_fee_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeChainId)]\\nunconstrained fn chain_id_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeVersion)]\\nunconstrained fn version_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeBlockNumber)]\\nunconstrained fn block_number_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeTimestamp)]\\nunconstrained fn timestamp_opcode() -> u64 {}\\n\\n#[oracle(avmOpcodeFeePerL2Gas)]\\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeFeePerDaGas)]\\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeL2GasLeft)]\\nunconstrained fn l2_gas_left_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeDaGasLeft)]\\nunconstrained fn da_gas_left_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeIsStaticCall)]\\nunconstrained fn is_static_call_opcode() -> Field {}\\n\\n#[oracle(avmOpcodeNoteHashExists)]\\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeEmitNoteHash)]\\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\\n\\n#[oracle(avmOpcodeNullifierExists)]\\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeEmitNullifier)]\\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\\n\\n#[oracle(avmOpcodeEmitUnencryptedLog)]\\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\\n\\n#[oracle(avmOpcodeL1ToL2MsgExists)]\\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\\n\\n#[oracle(avmOpcodeSendL2ToL1Msg)]\\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\\n\\n#[oracle(avmOpcodeCalldataCopy)]\\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\\n\\n#[oracle(avmOpcodeReturndataSize)]\\nunconstrained fn returndata_size_opcode() -> u32 {}\\n\\n#[oracle(avmOpcodeReturndataCopy)]\\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\\n\\n#[oracle(avmOpcodeReturn)]\\nunconstrained fn return_opcode(returndata: [Field]) {}\\n\\n// This opcode reverts using the exact data given. In general it should only be used\\n// to do rethrows, where the revert data is the same as the original revert data.\\n// For normal reverts, use Noir\'s `assert` which, on top of reverting, will also add\\n// an error selector to the revert data.\\n#[oracle(avmOpcodeRevert)]\\nunconstrained fn revert_opcode(revertdata: [Field]) {}\\n\\n#[oracle(avmOpcodeCall)]\\nunconstrained fn call_opcode(\\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\\n    address: AztecAddress,\\n    args: [Field],\\n) -> bool {}\\n\\n#[oracle(avmOpcodeStaticCall)]\\nunconstrained fn call_static_opcode(\\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\\n    address: AztecAddress,\\n    args: [Field],\\n) -> bool {}\\n\\n#[oracle(avmOpcodeStorageRead)]\\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\\n\\n#[oracle(avmOpcodeStorageWrite)]\\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\\n"},"150":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\\n};\\n\\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\\n\\nuse crate::hash::hash_args;\\nuse crate::oracle::arguments::pack_arguments;\\n\\npub trait CallInterface<let N: u32> {\\n    fn get_args(self) -> [Field] {\\n        self.args\\n    }\\n\\n    fn get_selector(self) -> FunctionSelector {\\n        self.selector\\n    }\\n\\n    fn get_name(self) -> str<N> {\\n        self.name\\n    }\\n\\n    fn get_contract_address(self) -> AztecAddress {\\n        self.target_contract\\n    }\\n\\n    fn get_is_static(self) -> bool {\\n        self.is_static\\n    }\\n}\\n\\npub struct PrivateCallInterface<let N: u32, T> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args_hash: Field,\\n    pub args: [Field],\\n    pub return_type: T,\\n    pub is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        pack_arguments(self.args);\\n        let returns = context.call_private_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            false,\\n        );\\n        let unpacked: T = returns.unpack_into();\\n        unpacked\\n    }\\n\\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        pack_arguments(self.args);\\n        let returns = context.call_private_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            true,\\n        );\\n        returns.unpack_into()\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\\n\\npub struct PrivateVoidCallInterface<let N: u32> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args_hash: Field,\\n    pub args: [Field],\\n    pub return_type: (),\\n    pub is_static: bool,\\n}\\n\\nimpl<let N: u32> PrivateVoidCallInterface<N> {\\n    pub fn call(self, context: &mut PrivateContext) {\\n        pack_arguments(self.args);\\n        context\\n            .call_private_function_with_packed_args(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                false,\\n            )\\n            .assert_empty();\\n    }\\n\\n    pub fn view(self, context: &mut PrivateContext) {\\n        pack_arguments(self.args);\\n        context\\n            .call_private_function_with_packed_args(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                true,\\n            )\\n            .assert_empty();\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\\n\\npub struct PrivateStaticCallInterface<let N: u32, T> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args_hash: Field,\\n    pub args: [Field],\\n    pub return_type: T,\\n    pub is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        pack_arguments(self.args);\\n        let returns = context.call_private_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            self.args_hash,\\n            true,\\n        );\\n        returns.unpack_into()\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\\n\\npub struct PrivateStaticVoidCallInterface<let N: u32> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args_hash: Field,\\n    pub args: [Field],\\n    pub return_type: (),\\n    pub is_static: bool,\\n}\\n\\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\\n    pub fn view(self, context: &mut PrivateContext) {\\n        pack_arguments(self.args);\\n        context\\n            .call_private_function_with_packed_args(\\n                self.target_contract,\\n                self.selector,\\n                self.args_hash,\\n                true,\\n            )\\n            .assert_empty();\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\\n\\npub struct PublicCallInterface<let N: u32, T> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args: [Field],\\n    pub gas_opts: GasOpts,\\n    pub return_type: T,\\n    pub is_static: bool,\\n}\\n\\nimpl<let N: u32, T> PublicCallInterface<N, T> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        pack_arguments(self.args);\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            false,\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        pack_arguments(self.args);\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\\n\\npub struct PublicVoidCallInterface<let N: u32> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args: [Field],\\n    pub return_type: (),\\n    pub is_static: bool,\\n    pub gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32> PublicVoidCallInterface<N> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn call(self, context: &mut PublicContext) {\\n        let returns = context.call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub unconstrained fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub fn enqueue(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        pack_arguments(self.args);\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            false,\\n        )\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        pack_arguments(self.args);\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\\n\\npub struct PublicStaticCallInterface<let N: u32, T> {\\n    pub target_contract: AztecAddress,\\n    pub selector: FunctionSelector,\\n    pub name: str<N>,\\n    pub args: [Field],\\n    pub return_type: T,\\n    pub is_static: bool,\\n    pub gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\\n    where\\n        T: Deserialize<M>,\\n    {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        Deserialize::deserialize(returns.as_array::<M>())\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        pack_arguments(self.args);\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n\\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\\n\\npub struct PublicStaticVoidCallInterface<let N: u32> {\\n    target_contract: AztecAddress,\\n    selector: FunctionSelector,\\n    name: str<N>,\\n    args: [Field],\\n    return_type: (),\\n    is_static: bool,\\n    gas_opts: GasOpts,\\n}\\n\\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\\n        self.gas_opts = gas_opts;\\n        self\\n    }\\n\\n    pub unconstrained fn view(self, context: &mut PublicContext) {\\n        let returns = context.static_call_public_function(\\n            self.target_contract,\\n            self.selector,\\n            self.args,\\n            self.gas_opts,\\n        );\\n        assert(returns.len() == 0);\\n    }\\n\\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\\n        let args_hash = hash_args(self.args);\\n        pack_arguments(self.args);\\n        context.call_public_function_with_packed_args(\\n            self.target_contract,\\n            self.selector,\\n            args_hash,\\n            /*static=*/\\n            true,\\n        )\\n    }\\n}\\n"},"156":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use dep::protocol_types::debug_log::debug_log_format;\\n\\nuse crate::{\\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\\n    hash::{ArgsHasher, hash_args_array},\\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\\n    messaging::process_l1_to_l2_message,\\n    oracle::{\\n        arguments,\\n        block_header::get_block_header_at,\\n        call_private_function::call_private_function_internal,\\n        enqueue_public_function_call::{\\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\\n            set_public_teardown_function_call_internal,\\n        },\\n        key_validation_request::get_key_validation_request,\\n        returns::pack_returns,\\n    },\\n};\\nuse dep::protocol_types::{\\n    abis::{\\n        call_context::CallContext,\\n        function_selector::FunctionSelector,\\n        log::Log,\\n        log_hash::LogHash,\\n        max_block_number::MaxBlockNumber,\\n        note_hash::NoteHash,\\n        nullifier::Nullifier,\\n        private_call_request::PrivateCallRequest,\\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\\n        private_log::PrivateLogData,\\n        public_call_request::PublicCallRequest,\\n        read_request::ReadRequest,\\n        side_effect::Counted,\\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\\n    },\\n    address::{AztecAddress, EthAddress},\\n    block_header::BlockHeader,\\n    constants::{\\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\\n    },\\n    messaging::l2_to_l1_message::L2ToL1Message,\\n    traits::Empty,\\n};\\n\\n// When finished, one can call .finish() to convert back to the abi\\npub struct PrivateContext {\\n    // docs:start:private-context\\n    pub inputs: PrivateContextInputs,\\n    pub side_effect_counter: u32,\\n\\n    pub min_revertible_side_effect_counter: u32,\\n    pub is_fee_payer: bool,\\n\\n    pub args_hash: Field,\\n    pub return_hash: Field,\\n\\n    pub max_block_number: MaxBlockNumber,\\n\\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\\n\\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\\n\\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\\n    pub public_teardown_call_request: PublicCallRequest,\\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\\n    // docs:end:private-context\\n\\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\\n    pub historical_header: BlockHeader,\\n\\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\\n\\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\\n    // fetching the same request multiple times.\\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\\n}\\n\\nimpl PrivateContext {\\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\\n        PrivateContext {\\n            inputs,\\n            side_effect_counter: inputs.start_side_effect_counter + 1,\\n            min_revertible_side_effect_counter: 0,\\n            is_fee_payer: false,\\n            args_hash,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            historical_header: inputs.historical_header,\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n\\n    pub fn msg_sender(self) -> AztecAddress {\\n        self.inputs.call_context.msg_sender\\n    }\\n\\n    pub fn this_address(self) -> AztecAddress {\\n        self.inputs.call_context.contract_address\\n    }\\n\\n    pub fn chain_id(self) -> Field {\\n        self.inputs.tx_context.chain_id\\n    }\\n\\n    pub fn version(self) -> Field {\\n        self.inputs.tx_context.version\\n    }\\n\\n    pub fn selector(self) -> FunctionSelector {\\n        self.inputs.call_context.function_selector\\n    }\\n\\n    pub fn get_args_hash(self) -> Field {\\n        self.args_hash\\n    }\\n\\n    pub fn push_note_hash(&mut self, note_hash: Field) {\\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\\n\\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\\n        debug_log_format(\\n            \\"Context.note_hashes, after pushing new note hash: {0}\\",\\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\\n        );\\n    }\\n\\n    pub fn push_nullifier(&mut self, nullifier: Field) {\\n        self.nullifiers.push(\\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\\n        );\\n    }\\n\\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\\n        self.nullifiers.push(\\n            Nullifier {\\n                value: nullifier,\\n                note_hash: nullified_note_hash,\\n                counter: self.next_counter(),\\n            },\\n        );\\n    }\\n\\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\\n    // included in).\\n    pub fn get_block_header(self) -> BlockHeader {\\n        self.historical_header\\n    }\\n\\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\\n    // of historical header.\\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\\n        get_block_header_at(block_number, self)\\n    }\\n\\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\\n        pack_returns(returns_hasher.fields);\\n        self.return_hash = returns_hasher.hash();\\n    }\\n\\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\\n        PrivateCircuitPublicInputs {\\n            call_context: self.inputs.call_context,\\n            args_hash: self.args_hash,\\n            returns_hash: self.return_hash,\\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\\n            is_fee_payer: self.is_fee_payer,\\n            max_block_number: self.max_block_number,\\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\\n            key_validation_requests_and_generators: self\\n                .key_validation_requests_and_generators\\n                .storage(),\\n            note_hashes: self.note_hashes.storage(),\\n            nullifiers: self.nullifiers.storage(),\\n            private_call_requests: self.private_call_requests.storage(),\\n            public_call_requests: self.public_call_requests.storage(),\\n            public_teardown_call_request: self.public_teardown_call_request,\\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\\n            end_side_effect_counter: self.side_effect_counter,\\n            private_logs: self.private_logs.storage(),\\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\\n            historical_header: self.historical_header,\\n            tx_context: self.inputs.tx_context,\\n        }\\n    }\\n\\n    pub fn set_as_fee_payer(&mut self) {\\n        dep::protocol_types::debug_log::debug_log_format(\\n            \\"Setting {0} as fee payer\\",\\n            [self.this_address().to_field()],\\n        );\\n        self.is_fee_payer = true;\\n    }\\n\\n    pub fn end_setup(&mut self) {\\n        // dep::protocol_types::debug_log::debug_log_format(\\n        //     \\"Ending setup at counter {0}\\",\\n        //     [self.side_effect_counter as Field]\\n        // );\\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\\n    }\\n\\n    // docs:start:max-block-number\\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\\n        // docs:end:max-block-number\\n        self.max_block_number =\\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\\n    }\\n\\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\\n        self.note_hash_read_requests.push(side_effect);\\n    }\\n\\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\\n        self.nullifier_read_requests.push(request);\\n    }\\n\\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\\n    }\\n\\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\\n    }\\n\\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\\n        let cached_request =\\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\\n\\n        if cached_request.pk_m.hash() == pk_m_hash {\\n            // We get a match so the cached request is the latest one\\n            cached_request.sk_app\\n        } else {\\n            // We didn\'t get a match meaning the cached result is stale\\n            // Typically we\'d validate keys by showing that they are the preimage of `pk_m_hash`, but that\'d require\\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\\n            // to `pk_m_hash`.\\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\\n            assert(request.pk_m.hash() == pk_m_hash);\\n\\n            self.key_validation_requests_and_generators.push(\\n                KeyValidationRequestAndGenerator {\\n                    request,\\n                    sk_app_generator: sk_generators[key_index],\\n                },\\n            );\\n            self.last_key_validation_requests[key_index] = Option::some(request);\\n            request.sk_app\\n        }\\n    }\\n\\n    // docs:start:context_message_portal\\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\\n        // docs:end:context_message_portal\\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\\n        self.l2_to_l1_msgs.push(message);\\n    }\\n\\n    // docs:start:context_consume_l1_to_l2_message\\n    // docs:start:consume_l1_to_l2_message\\n    pub fn consume_l1_to_l2_message(\\n        &mut self,\\n        content: Field,\\n        secret: Field,\\n        sender: EthAddress,\\n        leaf_index: Field,\\n    ) {\\n        // docs:end:context_consume_l1_to_l2_message\\n        let nullifier = process_l1_to_l2_message(\\n            self.historical_header.state.l1_to_l2_message_tree.root,\\n            self.this_address(),\\n            sender,\\n            self.chain_id(),\\n            self.version(),\\n            content,\\n            secret,\\n            leaf_index,\\n        );\\n\\n        // Push nullifier (and the \\"commitment\\" corresponding to this can be \\"empty\\")\\n        self.push_nullifier(nullifier)\\n    }\\n    // docs:end:consume_l1_to_l2_message\\n\\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn emit_raw_note_log(\\n        &mut self,\\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\\n        note_hash_counter: u32,\\n    ) {\\n        let counter = self.next_counter();\\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\\n        self.private_logs.push(private_log);\\n    }\\n\\n    pub fn call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        arguments::pack_arguments_array(args);\\n        self.call_private_function_with_packed_args(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) -> PackedReturns {\\n        let args_hash = hash_args_array(args);\\n        arguments::pack_arguments_array(args);\\n        self.call_private_function_with_packed_args(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_private_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) -> PackedReturns {\\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_private_function_with_packed_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) -> PackedReturns {\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        let start_side_effect_counter = self.side_effect_counter;\\n\\n        // The oracle simulates the private call and returns the value of the side effects counter after execution of\\n        // the call (which means that end_side_effect_counter - start_side_effect_counter is the number of side effects\\n        // that took place), along with the hash of the return values. We validate these by requesting a private kernel\\n        // iteration in which the return values are constrained to hash to `returns_hash` and the side effects counter\\n        // to increment from start to end.\\n        let (end_side_effect_counter, returns_hash) = unsafe {\\n            call_private_function_internal(\\n                contract_address,\\n                function_selector,\\n                args_hash,\\n                start_side_effect_counter,\\n                is_static_call,\\n            )\\n        };\\n\\n        self.private_call_requests.push(\\n            PrivateCallRequest {\\n                call_context: CallContext {\\n                    msg_sender: self.this_address(),\\n                    contract_address,\\n                    function_selector,\\n                    is_static_call,\\n                },\\n                args_hash,\\n                returns_hash,\\n                start_side_effect_counter,\\n                end_side_effect_counter,\\n            },\\n        );\\n\\n        // TODO (fees) figure out why this crashes the prover and enable it\\n        // we need this in order to pay fees inside child call contexts\\n        // assert(\\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\\n        //     | (item.public_inputs.min_revertible_side_effect_counter\\n        //         > self.min_revertible_side_effect_counter)\\n        // );\\n        // if item.public_inputs.min_revertible_side_effect_counter\\n        //     > self.min_revertible_side_effect_counter {\\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\\n        // }\\n        self.side_effect_counter = end_side_effect_counter + 1;\\n        PackedReturns::new(returns_hash)\\n    }\\n\\n    pub fn call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        arguments::pack_arguments_array(args);\\n        self.call_public_function_with_packed_args(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        arguments::pack_arguments_array(args);\\n        self.call_public_function_with_packed_args(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            true,\\n        )\\n    }\\n\\n    pub fn call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\\n    }\\n\\n    pub fn static_call_public_function_no_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n    ) {\\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\\n    }\\n\\n    pub fn call_public_function_with_packed_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        // WARNING: This is insecure and should be temporary!\\n        // The oracle repacks the arguments and returns a new args_hash.\\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        // We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        // b) this is only temporary.\\n        let args_hash = enqueue_public_function_call_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            counter,\\n            is_static_call,\\n        );\\n\\n        // Public calls are rerouted through the dispatch function.\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        let call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n\\n        self.public_call_requests.push(Counted::new(call_request, counter));\\n    }\\n\\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args: [Field; ARGS_COUNT],\\n    ) {\\n        let args_hash = hash_args_array(args);\\n        arguments::pack_arguments_array(args);\\n        self.set_public_teardown_function_with_packed_args(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            false,\\n        )\\n    }\\n\\n    pub fn set_public_teardown_function_with_packed_args(\\n        &mut self,\\n        contract_address: AztecAddress,\\n        function_selector: FunctionSelector,\\n        args_hash: Field,\\n        is_static_call: bool,\\n    ) {\\n        let counter = self.next_counter();\\n\\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\\n        // WARNING: This is insecure and should be temporary!\\n        // The oracle repacks the arguments and returns a new args_hash.\\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\\n        // We don\'t validate or compute it in the circuit because a) it\'s harder to do with slices, and\\n        // b) this is only temporary.\\n        let args_hash = set_public_teardown_function_call_internal(\\n            contract_address,\\n            function_selector,\\n            args_hash,\\n            counter,\\n            is_static_call,\\n        );\\n\\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\\n\\n        self.public_teardown_call_request = PublicCallRequest {\\n            msg_sender: self.this_address(),\\n            contract_address,\\n            function_selector,\\n            is_static_call,\\n            args_hash,\\n        };\\n    }\\n\\n    fn next_counter(&mut self) -> u32 {\\n        let counter = self.side_effect_counter;\\n        self.side_effect_counter += 1;\\n        counter\\n    }\\n}\\n\\nimpl Empty for PrivateContext {\\n    fn empty() -> Self {\\n        PrivateContext {\\n            inputs: PrivateContextInputs::empty(),\\n            side_effect_counter: 0 as u32,\\n            min_revertible_side_effect_counter: 0 as u32,\\n            is_fee_payer: false,\\n            args_hash: 0,\\n            return_hash: 0,\\n            max_block_number: MaxBlockNumber::empty(),\\n            note_hash_read_requests: BoundedVec::new(),\\n            nullifier_read_requests: BoundedVec::new(),\\n            key_validation_requests_and_generators: BoundedVec::new(),\\n            note_hashes: BoundedVec::new(),\\n            nullifiers: BoundedVec::new(),\\n            private_call_requests: BoundedVec::new(),\\n            public_call_requests: BoundedVec::new(),\\n            public_teardown_call_request: PublicCallRequest::empty(),\\n            l2_to_l1_msgs: BoundedVec::new(),\\n            historical_header: BlockHeader::empty(),\\n            private_logs: BoundedVec::new(),\\n            contract_class_logs_hashes: BoundedVec::new(),\\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\\n        }\\n    }\\n}\\n"},"162":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use crate::{\\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\\n    oracle::{\\n        key_validation_request::get_key_validation_request,\\n        keys::get_public_keys_and_partial_address,\\n    },\\n};\\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\\n\\nmod test;\\n\\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\\n}\\n\\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\\n// function defined on `PrivateContext`.\\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\\n}\\n\\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\\n// read keys that are not required by the caller can simply be discarded.\\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\\n    // Public keys are constrained by showing their inclusion in the address\'s preimage.\\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\\n    assert_eq(\\n        account,\\n        AztecAddress::compute(public_keys, partial_address),\\n        \\"Invalid public keys hint for address\\",\\n    );\\n\\n    public_keys\\n}\\n"},"187":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Deserialize, Serialize};\\n\\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\\nglobal U8_SERIALIZED_LEN: u32 = 1;\\nglobal U16_SERIALIZED_LEN: u32 = 1;\\nglobal U32_SERIALIZED_LEN: u32 = 1;\\nglobal U64_SERIALIZED_LEN: u32 = 1;\\nglobal U128_SERIALIZED_LEN: u32 = 1;\\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\\nglobal I8_SERIALIZED_LEN: u32 = 1;\\nglobal I16_SERIALIZED_LEN: u32 = 1;\\nglobal I32_SERIALIZED_LEN: u32 = 1;\\nglobal I64_SERIALIZED_LEN: u32 = 1;\\n\\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\\n        fields[0] as bool\\n    }\\n}\\n\\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u8\\n    }\\n}\\n\\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u16\\n    }\\n}\\n\\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u32\\n    }\\n}\\n\\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\\n        fields[0] as u64\\n    }\\n}\\n\\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\\n        [self.to_integer()]\\n    }\\n}\\n\\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\\n        U128::from_integer(fields[0])\\n    }\\n}\\n\\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\\n        [self]\\n    }\\n}\\n\\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\\n        fields[0]\\n    }\\n}\\n\\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i8\\n    }\\n}\\n\\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i16\\n    }\\n}\\n\\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i32\\n    }\\n}\\n\\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\\n        [self as Field]\\n    }\\n}\\n\\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\\n        fields[0] as i64\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\\nwhere\\n    T: Serialize<M>,\\n{\\n    fn serialize(self) -> [Field; N * M] {\\n        let mut result: [Field; N * M] = std::mem::zeroed();\\n        let mut serialized: [Field; M] = std::mem::zeroed();\\n        for i in 0..N {\\n            serialized = self[i].serialize();\\n            for j in 0..M {\\n                result[i * M + j] = serialized[j];\\n            }\\n        }\\n        result\\n    }\\n}\\n\\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\\nwhere\\n    T: Deserialize<M>,\\n{\\n    fn deserialize(fields: [Field; N * M]) -> Self {\\n        let mut reader = crate::utils::reader::Reader::new(fields);\\n        let mut result: [T; N] = std::mem::zeroed();\\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\\n    }\\n}\\n\\n#[test]\\nfn test_u16_serialization() {\\n    let a: u16 = 10;\\n    assert_eq(a, u16::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i8_serialization() {\\n    let a: i8 = -10;\\n    assert_eq(a, i8::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i16_serialization() {\\n    let a: i16 = -10;\\n    assert_eq(a, i16::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i32_serialization() {\\n    let a: i32 = -10;\\n    assert_eq(a, i32::deserialize(a.serialize()));\\n}\\n\\n#[test]\\nfn test_i64_serialization() {\\n    let a: i64 = -10;\\n    assert_eq(a, i64::deserialize(a.serialize()));\\n}\\n"},"189":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\\n\\npub global POINT_LENGTH: u32 = 3;\\n\\nimpl Serialize<POINT_LENGTH> for Point {\\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\\n        [self.x, self.y, self.is_infinite as Field]\\n    }\\n}\\n\\nimpl Hash for Point {\\n    fn hash(self) -> Field {\\n        poseidon2_hash(self.serialize())\\n    }\\n}\\n\\nimpl Empty for Point {\\n    /// Note: Does not return a valid point on curve - instead represents an empty/\\"unpopulated\\" point struct (e.g.\\n    /// empty/unpopulated value in an array of points).\\n    fn empty() -> Self {\\n        Point { x: 0, y: 0, is_infinite: false }\\n    }\\n}\\n\\nimpl Deserialize<POINT_LENGTH> for Point {\\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\\n    }\\n}\\n"},"191":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr","source":"pub mod assert_array_appended;\\npub mod assert_array_prepended;\\npub mod assert_combined_array;\\npub mod assert_combined_transformed_array;\\npub mod assert_exposed_sorted_transformed_value_array;\\npub mod assert_sorted_array;\\npub mod assert_sorted_transformed_value_array;\\npub mod assert_split_sorted_transformed_value_arrays;\\npub mod assert_split_transformed_value_arrays;\\npub mod get_sorted_result;\\npub mod get_sorted_tuple;\\npub mod sort_by;\\npub mod sort_by_counter;\\n\\n// Re-exports.\\npub use assert_array_appended::{\\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\\n    assert_array_appended_scoped,\\n};\\npub use assert_array_prepended::assert_array_prepended;\\npub use assert_combined_array::{assert_combined_array, combine_arrays};\\npub use assert_combined_transformed_array::{\\n    assert_combined_transformed_array, combine_and_transform_arrays,\\n};\\npub use assert_exposed_sorted_transformed_value_array::{\\n    assert_exposed_sorted_transformed_value_array,\\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\\n};\\npub use assert_sorted_array::assert_sorted_array;\\npub use assert_sorted_transformed_value_array::{\\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\\n};\\npub use assert_split_sorted_transformed_value_arrays::{\\n    assert_split_sorted_transformed_value_arrays_asc,\\n    assert_split_sorted_transformed_value_arrays_desc,\\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\\n};\\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\\npub use get_sorted_result::{get_sorted_result, SortedResult};\\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\\n\\nuse crate::traits::{Empty, is_empty};\\n\\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\\n    src: [Field; SRC_LEN],\\n    offset: u32,\\n) -> [Field; DST_LEN] {\\n    assert(offset + DST_LEN <= SRC_LEN, \\"offset too large\\");\\n\\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\\n    for i in 0..DST_LEN {\\n        dst[i] = src[i + offset];\\n    }\\n\\n    dst\\n}\\n\\n// Helper function to convert a validated array to BoundedVec.\\n// Important: Only use it for validated arrays: validate_array(array) should be true.\\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\\nwhere\\n    T: Empty + Eq,\\n{\\n    let len = array_length(array);\\n    BoundedVec::from_parts_unchecked(array, len)\\n}\\n\\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\\n    array: [T; N],\\n    find: fn[Env](T) -> bool,\\n) -> u32 {\\n    let mut index = N;\\n    for i in 0..N {\\n        if (index == N) & find(array[i]) {\\n            index = i;\\n        }\\n    }\\n    index\\n}\\n\\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\\n// valid.\\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut seen_empty = false;\\n    let mut length = 0;\\n    for i in 0..N {\\n        if is_empty(array[i]) {\\n            seen_empty = true;\\n        } else {\\n            assert(seen_empty == false, \\"invalid array\\");\\n            length += 1;\\n        }\\n    }\\n    length\\n}\\n\\n// Helper function to count the number of non-empty elements in a validated array.\\n// Important: Only use it for validated arrays: validate_array(array) should be true.\\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\\nwhere\\n    T: Empty + Eq,\\n{\\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\\n    if length != 0 {\\n        assert(!is_empty(array[length - 1]));\\n    }\\n    if length != N {\\n        assert(is_empty(array[length]));\\n    }\\n    length\\n}\\n\\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\\n    let mut result = [array1[0]; N + M];\\n    for i in 1..N {\\n        result[i] = array1[i];\\n    }\\n    for i in 0..M {\\n        result[i + N] = array2[i];\\n    }\\n    result\\n}\\n\\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\\nwhere\\n    T: Empty + Eq,\\n{\\n    let mut result: [T; N] = [T::empty(); N];\\n    let mut i = 0;\\n    for elem in array1 {\\n        if !is_empty(elem) {\\n            result[i] = elem;\\n            i += 1;\\n        }\\n    }\\n    for elem in array2 {\\n        if !is_empty(elem) {\\n            result[i] = elem;\\n            i += 1;\\n        }\\n    }\\n    result\\n}\\n\\n// Helper fn to create a subarray from a given array\\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\\nwhere\\n    T: Empty,\\n{\\n    assert(M + offset <= N, \\"Subarray length larger than array length\\");\\n    let mut result: [T; M] = [T::empty(); M];\\n    for i in 0..M {\\n        result[i] = array[offset + i];\\n    }\\n    result\\n}\\n\\npub fn check_permutation<T, let N: u32>(\\n    original_array: [T; N],\\n    permuted_array: [T; N],\\n    original_indexes: [u32; N],\\n)\\nwhere\\n    T: Eq + Empty,\\n{\\n    let mut seen_value = [false; N];\\n    for i in 0..N {\\n        let index = original_indexes[i];\\n        let original_value = original_array[index];\\n        assert(permuted_array[i].eq(original_value), \\"Invalid index\\");\\n        assert(!seen_value[index], \\"Duplicated index\\");\\n        seen_value[index] = true;\\n    }\\n}\\n\\n#[test]\\nfn smoke_validate_array() {\\n    let valid_array: [Field; 0] = [];\\n    assert(validate_array(valid_array) == 0);\\n\\n    let valid_array = [0];\\n    assert(validate_array(valid_array) == 0);\\n\\n    let valid_array = [3];\\n    assert(validate_array(valid_array) == 1);\\n\\n    let valid_array = [1, 2, 3];\\n    assert(validate_array(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0];\\n    assert(validate_array(valid_array) == 3);\\n\\n    let valid_array = [1, 2, 3, 0, 0];\\n    assert(validate_array(valid_array) == 3);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case0() {\\n    let invalid_array = [0, 1];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case1() {\\n    let invalid_array = [1, 0, 0, 1, 0];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test(should_fail_with = \\"invalid array\\")]\\nfn smoke_validate_array_invalid_case2() {\\n    let invalid_array = [0, 0, 0, 0, 1];\\n    let _ = validate_array(invalid_array);\\n}\\n\\n#[test]\\nfn test_empty_array_length() {\\n    assert_eq(array_length([0]), 0);\\n    assert_eq(array_length([0, 0, 0]), 0);\\n}\\n\\n#[test]\\nfn test_array_length() {\\n    assert_eq(array_length([123]), 1);\\n    assert_eq(array_length([123, 0, 0]), 1);\\n    assert_eq(array_length([123, 456]), 2);\\n    assert_eq(array_length([123, 456, 0]), 2);\\n}\\n\\n#[test]\\nfn test_array_length_invalid_arrays() {\\n    // Result can be misleading (but correct) for invalid arrays.\\n    assert_eq(array_length([0, 0, 123]), 0);\\n    assert_eq(array_length([0, 123, 0]), 0);\\n    assert_eq(array_length([0, 123, 456]), 0);\\n    assert_eq(array_length([123, 0, 456]), 1);\\n}\\n\\n#[test]\\nfn find_index_greater_than_min() {\\n    let values = [10, 20, 30, 40];\\n    let min = 22;\\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\\n    assert_eq(index, 2);\\n}\\n\\n#[test]\\nfn find_index_not_found() {\\n    let values = [10, 20, 30, 40];\\n    let min = 100;\\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\\n    assert_eq(index, 4);\\n}\\n\\n#[test]\\nfn test_array_concat() {\\n    let array0 = [1, 2, 3];\\n    let array1 = [4, 5];\\n    let concated = array_concat(array0, array1);\\n    assert_eq(concated, [1, 2, 3, 4, 5]);\\n}\\n\\n#[test]\\nfn check_permutation_basic_test() {\\n    let original_array = [1, 2, 3];\\n    let permuted_array = [3, 1, 2];\\n    let indexes = [2, 0, 1];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n\\n#[test(should_fail_with = \\"Duplicated index\\")]\\nfn check_permutation_duplicated_index() {\\n    let original_array = [0, 1, 0];\\n    let permuted_array = [1, 0, 0];\\n    let indexes = [1, 0, 0];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n\\n#[test(should_fail_with = \\"Invalid index\\")]\\nfn check_permutation_invalid_index() {\\n    let original_array = [0, 1, 2];\\n    let permuted_array = [1, 0, 0];\\n    let indexes = [1, 0, 2];\\n    check_permutation(original_array, permuted_array, indexes);\\n}\\n"},"209":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\\n    data: [Field; N],\\n    offset: u32,\\n}\\n\\nimpl<let N: u32> Reader<N> {\\n    pub fn new(data: [Field; N]) -> Self {\\n        Self { data, offset: 0 }\\n    }\\n\\n    pub fn read(&mut self) -> Field {\\n        let result = self.data[self.offset];\\n        self.offset += 1;\\n        result\\n    }\\n\\n    pub fn read_u32(&mut self) -> u32 {\\n        self.read() as u32\\n    }\\n\\n    pub fn read_bool(&mut self) -> bool {\\n        self.read() as bool\\n    }\\n\\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\\n        let mut result = [0; K];\\n        for i in 0..K {\\n            result[i] = self.data[self.offset + i];\\n        }\\n        self.offset += K;\\n        result\\n    }\\n\\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\\n        let result = deserialise(self.read_array());\\n        result\\n    }\\n\\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\\n        &mut self,\\n        deserialise: fn([Field; K]) -> T,\\n        mut result: [T; C],\\n    ) -> [T; C] {\\n        for i in 0..C {\\n            result[i] = self.read_struct(deserialise);\\n        }\\n        result\\n    }\\n\\n    pub fn finish(self) {\\n        assert(self.offset == self.data.len(), \\"Reader did not read all data\\");\\n    }\\n}\\n"},"213":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\\n\\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\\nwhere\\n    K: ToField,\\n{\\n    poseidon2_hash([storage_slot, key.to_field()])\\n}\\n\\nmod test {\\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\\n\\n    #[test]\\n    fn test_derive_storage_slot_in_map_matches_typescript() {\\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\\n        let key = AztecAddress::from_field(\\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\\n        );\\n\\n        let slot = derive_storage_slot_in_map(map_slot, key);\\n\\n        // The following value was generated by `map_slot.test.ts`\\n        let slot_from_typescript =\\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\\n\\n        assert_eq(slot, slot_from_typescript);\\n    }\\n}\\n"},"217":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\\n    abis::{\\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\\n        function_selector::FunctionSelector,\\n        log_hash::{LogHash, ScopedLogHash},\\n        note_hash::ScopedNoteHash,\\n        nullifier::ScopedNullifier,\\n        private_log::{PrivateLog, PrivateLogData},\\n        side_effect::scoped::Scoped,\\n    },\\n    address::{AztecAddress, EthAddress},\\n    constants::{\\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\\n    },\\n    merkle_tree::root::root_from_sibling_path,\\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\\n    traits::{is_empty, ToField},\\n    utils::field::field_from_bytes_32_trunc,\\n};\\nuse super::utils::{arrays::array_concat, field::field_from_bytes};\\n\\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\\n\\n    hash_in_a_field\\n}\\n\\npub fn private_functions_root_from_siblings(\\n    selector: FunctionSelector,\\n    vk_hash: Field,\\n    function_leaf_index: Field,\\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\\n) -> Field {\\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\\n    let function_leaf = function_leaf_preimage.hash();\\n    root_from_sibling_path(\\n        function_leaf,\\n        function_leaf_index,\\n        function_leaf_sibling_path,\\n    )\\n}\\n\\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\\n    // Hashing tx hash with note index in tx is guaranteed to be unique\\n    poseidon2_hash_with_separator(\\n        [tx_hash, note_index_in_tx as Field],\\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\\n    )\\n}\\n\\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\\n    let inputs = [nonce, siloed_note_hash];\\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\\n}\\n\\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), note_hash],\\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\\n    )\\n}\\n\\n/// Computes unique note hashes from siloed note hashes\\npub fn compute_unique_siloed_note_hash(\\n    siloed_note_hash: Field,\\n    tx_hash: Field,\\n    note_index_in_tx: u32,\\n) -> Field {\\n    if siloed_note_hash == 0 {\\n        0\\n    } else {\\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\\n        compute_unique_note_hash(nonce, siloed_note_hash)\\n    }\\n}\\n\\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\\n    if note_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\\n    }\\n}\\n\\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\\n    poseidon2_hash_with_separator(\\n        [app.to_field(), nullifier],\\n        GENERATOR_INDEX__OUTER_NULLIFIER,\\n    )\\n}\\n\\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\\n    if nullifier.contract_address.is_zero() {\\n        nullifier.value() // Return value instead of 0 because the first nullifier\'s contract address is zero.\\n    } else {\\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\\n    }\\n}\\n\\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\\n    poseidon2_hash([contract_address.to_field(), field])\\n}\\n\\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\\n    if private_log.contract_address.is_zero() {\\n        private_log.inner.log\\n    } else {\\n        let mut fields = private_log.inner.log.fields;\\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\\n        PrivateLog { fields }\\n    }\\n}\\n\\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\\n    accumulate_sha256([address.to_field(), log_hash])\\n}\\n\\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\\n    if log_hash.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\\n    }\\n}\\n\\npub fn merkle_hash(left: Field, right: Field) -> Field {\\n    poseidon2_hash([left, right])\\n}\\n\\npub fn compute_l2_to_l1_hash(\\n    contract_address: AztecAddress,\\n    recipient: EthAddress,\\n    content: Field,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\\n\\n    let inputs =\\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\\n    for i in 0..inputs.len() {\\n        // TODO are bytes be in fr.to_buffer() ?\\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\\n        for j in 0..32 {\\n            bytes.push(item_bytes[j]);\\n        }\\n    }\\n\\n    sha256_to_field(bytes.storage())\\n}\\n\\npub fn silo_l2_to_l1_message(\\n    msg: ScopedL2ToL1Message,\\n    rollup_version_id: Field,\\n    chain_id: Field,\\n) -> Field {\\n    if msg.contract_address.is_zero() {\\n        0\\n    } else {\\n        compute_l2_to_l1_hash(\\n            msg.contract_address,\\n            msg.message.recipient,\\n            msg.message.content,\\n            rollup_version_id,\\n            chain_id,\\n        )\\n    }\\n}\\n\\n// Computes sha256 hash of 2 input hashes.\\n//\\n// NB: This method now takes in two 31 byte fields - it assumes that any input\\n// is the result of a sha_to_field hash and => is truncated\\n//\\n// TODO(Jan and David): This is used for the encrypted_log hashes.\\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\\n//\\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\\n    // This is a note about the cpp code, since it takes an array of Fields\\n    // instead of a U128.\\n    // 4 Field elements when converted to bytes will usually\\n    // occupy 4 * 32 = 128 bytes.\\n    // However, this function is making the assumption that each Field\\n    // only occupies 128 bits.\\n    //\\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\\n    // Concatentate two fields into 32x2 = 64 bytes\\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\\n    let mut hash_input_flattened = [0; 64];\\n    for offset in 0..input.len() {\\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n\\n    sha256_to_field(hash_input_flattened)\\n}\\n\\n// Computes the final logs hash for a tx.\\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\\n    let mut hash_input_flattened = [0; N * 32];\\n    for offset in 0..N {\\n        // TODO: This is not checking that the decomposition is smaller than P\\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\\n        for byte_index in 0..32 {\\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\\n        }\\n    }\\n    // Ideally we would push to a slice then hash, but there is no sha_slice\\n    // Hardcode to 256 bytes for now\\n    let mut hash = sha256_to_field(hash_input_flattened);\\n    // Not having a 0 value hash for empty logs causes issues with empty txs\\n    // used for padding. Returning early is currently unsupported.\\n    // We always provide sorted logs here, so 0 being empty means all are empty.\\n    if is_empty(logs[0]) {\\n        hash = 0;\\n    }\\n    hash\\n}\\n\\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\\n    crate::hash::poseidon2_hash(key)\\n}\\n\\n#[inline_always]\\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\\n}\\n\\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\\n    poseidon2_hash(inputs_with_separator)\\n}\\n\\n// Performs a fixed length hash with a subarray of the given input.\\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\\n// Using stdlib poseidon, this will always absorb an extra 1 as a \'variable\' hash, and not match spongeblob.squeeze()\\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\\n#[no_predicates]\\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\\n    sponge.squeeze()\\n}\\n\\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\\n// and absorbing in chunks of 3 below.\\n#[no_predicates]\\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n    // fixed-length and variable-length hashes do not collide)\\n    if in_len != N {\\n        sponge.absorb(1);\\n    }\\n    sponge.squeeze()\\n}\\n\\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\\n// The below code forces the compiler to:\\n//  - absorb normally up to 2 times to set cache_size to 1\\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\\n//  - absorb normally up to 2 times to add any remaining values to the hash\\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\\n\\n#[no_predicates]\\nfn poseidon2_absorb_chunks<let N: u32>(\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n) -> std::hash::poseidon2::Poseidon2 {\\n    let two_pow_64 = 18446744073709551616;\\n    let iv: Field = (in_len as Field) * two_pow_64;\\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\\n    // since we cannot isolate computation branches. The below is just to avoid that.\\n    let shift = if in_len == 0 { 0 } else { 1 };\\n    if in_len != 0 {\\n        // cache_size = 0, init absorb\\n        sponge.cache[0] = input[0];\\n        sponge.cache_size = 1;\\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\\n        // max_remainder = (N - 1) % 3;\\n        // max_chunks = (N - 1 - max_remainder) / 3;\\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            variable,\\n            shift,\\n        );\\n    }\\n    sponge\\n}\\n\\n// NB: If it\'s not required to check that the non-absorbed elts of \'input\' are 0s, set skip_0_check=true\\n#[no_predicates]\\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\\n    in_sponge: std::hash::poseidon2::Poseidon2,\\n    input: [Field; N],\\n    in_len: u32,\\n    skip_0_check: bool,\\n) -> std::hash::poseidon2::Poseidon2 {\\n    let mut sponge = in_sponge;\\n    // \'shift\' is to account for already added inputs\\n    let mut shift = 0;\\n    // \'stop\' is to avoid an underflow when inputting in_len = 0\\n    let mut stop = false;\\n    for i in 0..3 {\\n        if shift == in_len {\\n            stop = true;\\n        }\\n        if (sponge.cache_size != 1) & (!stop) {\\n            sponge.absorb(input[i]);\\n            shift += 1;\\n        }\\n    }\\n    sponge = if stop {\\n        sponge\\n    } else {\\n        // max_chunks = (N - (N % 3)) / 3;\\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\\n            sponge,\\n            input,\\n            in_len,\\n            skip_0_check,\\n            shift,\\n        )\\n    };\\n    sponge\\n}\\n\\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\\n// shift - the num of elts already absorbed to ensure the sponge\'s cache_size = 1\\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\\n// NB: The 0 checks (\'Found non-zero field...\') are messy, but having a separate loop over N to check\\n// for 0s costs 3N gates. Current approach is approx 2N gates.\\n#[no_predicates]\\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\\n    in_sponge: std::hash::poseidon2::Poseidon2,\\n    input: [Field; N],\\n    in_len: u32,\\n    variable: bool,\\n    shift: u32,\\n) -> std::hash::poseidon2::Poseidon2 {\\n    assert(in_len <= N, \\"Given in_len to absorb is larger than the input array len\\");\\n    // When we have an existing sponge, we may have a shift of 0, and the final \'k+2\' below = N\\n    // The below avoids an overflow\\n    let skip_last = 3 * M == N;\\n    // Writing in_sponge: &mut does not compile\\n    let mut sponge = in_sponge;\\n    let mut should_add = true;\\n    // The num of things left over after absorbing in 3s\\n    let remainder = (in_len - shift) % 3;\\n    // The num of chunks of 3 to absorb (maximum M)\\n    let chunks = (in_len - shift - remainder) / 3;\\n    for i in 0..M {\\n        // Now we loop through cache size = 1 -> 3\\n        should_add &= i != chunks;\\n        // This is the index at the start of the chunk (for readability)\\n        let k = 3 * i + shift;\\n        if should_add {\\n            // cache_size = 1, 2 => just assign\\n            sponge.cache[1] = input[k];\\n            sponge.cache[2] = input[k + 1];\\n            // cache_size = 3 => duplex + perm\\n            for j in 0..3 {\\n                sponge.state[j] += sponge.cache[j];\\n            }\\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\\n            sponge.cache[0] = input[k + 2];\\n            // cache_size is now 1 again, repeat loop\\n        } else if (!variable) & (i != chunks) {\\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\\n            // NB: we don\'t check at i == chunks, because that chunk contains elts to be absorbed or checked below\\n            let last_0 = if (i == M - 1) & (skip_last) {\\n                0\\n            } else {\\n                input[k + 2]\\n            };\\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\\n            assert(all_0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    // we have \'remainder\' num of items left to absorb\\n    should_add = true;\\n    // below is to avoid overflows (i.e. if inlen is close to N)\\n    let mut should_check = !variable;\\n    for i in 0..3 {\\n        should_add &= i != remainder;\\n        should_check &= in_len - remainder + i != N;\\n        if should_add {\\n            // we want to absorb the final \'remainder\' items\\n            sponge.absorb(input[in_len - remainder + i]);\\n        } else if should_check {\\n            assert(input[in_len - remainder + i] == 0, \\"Found non-zero field after breakpoint\\");\\n        }\\n    }\\n    sponge\\n}\\n\\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\\nwhere\\n    T: ToField,\\n{\\n    let in_len = inputs.len() + 1;\\n    let two_pow_64 = 18446744073709551616;\\n    let iv: Field = (in_len as Field) * two_pow_64;\\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\\n    sponge.absorb(separator.to_field());\\n\\n    for i in 0..inputs.len() {\\n        sponge.absorb(inputs[i]);\\n    }\\n\\n    sponge.squeeze()\\n}\\n\\n#[no_predicates]\\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\\n    let mut fields = [0; (N + 30) / 31];\\n    let mut field_index = 0;\\n    let mut current_field = [0; 31];\\n    for i in 0..inputs.len() {\\n        let index = i % 31;\\n        current_field[index] = inputs[i];\\n        if index == 30 {\\n            fields[field_index] = field_from_bytes(current_field, false);\\n            current_field = [0; 31];\\n            field_index += 1;\\n        }\\n    }\\n    if field_index != fields.len() {\\n        fields[field_index] = field_from_bytes(current_field, false);\\n    }\\n    poseidon2_hash(fields)\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\\n    assert(sub_chunk_hash == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_matches_variable() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\\n    assert(variable_chunk_hash == variable_len_hash);\\n}\\n\\n#[test]\\nfn existing_sponge_poseidon_chunks_matches_fixed() {\\n    let in_len = 501;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut fixed_input = [3; 501];\\n    assert(in_len == fixed_input.len()); // sanity check\\n    for i in 0..in_len {\\n        input[i] = 3;\\n    }\\n    // absorb 250 of the 501 things\\n    let two_pow_64 = 18446744073709551616;\\n    let empty_sponge = std::hash::poseidon2::Poseidon2::new((in_len as Field) * two_pow_64);\\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\\n    assert(final_sponge.squeeze() == fixed_len_hash);\\n}\\n\\n#[test]\\nfn poseidon_chunks_empty_inputs() {\\n    let in_len = 0;\\n    let mut input: [Field; 4096] = [0; 4096];\\n    let mut contructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\\n    let mut first_sponge =\\n        poseidon2_absorb_chunks_existing_sponge(contructed_empty_sponge, input, in_len, true);\\n    assert(first_sponge.squeeze() == contructed_empty_sponge.squeeze());\\n}\\n\\n#[test]\\nfn smoke_sha256_to_field() {\\n    let full_buffer = [\\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\\n    ];\\n    let result = sha256_to_field(full_buffer);\\n\\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\\n\\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\\n    let result_bytes = std::hash::sha256(full_buffer);\\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\\n    assert(truncated_field == result);\\n    let mod_res = result + (result_bytes[31] as Field);\\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\\n}\\n\\n#[test]\\nfn compute_l2_l1_hash() {\\n    // All zeroes\\n    let hash_result =\\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\\n\\n    // Non-zero case\\n    let hash_result = compute_l2_to_l1_hash(\\n        AztecAddress::from_field(1),\\n        EthAddress::from_field(3),\\n        5,\\n        2,\\n        4,\\n    );\\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\\n}\\n\\n#[test]\\nfn silo_l2_to_l1_message_matches_typescript() {\\n    let version = 4;\\n    let chainId = 5;\\n\\n    let hash = silo_l2_to_l1_message(\\n        ScopedL2ToL1Message {\\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\\n            contract_address: AztecAddress::from_field(3),\\n        },\\n        version,\\n        chainId,\\n    );\\n\\n    // The following value was generated by `l2_to_l1_message.test.ts`\\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\\n\\n    assert_eq(hash, hash_from_typescript);\\n}\\n"},"229":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\\n    abis::function_selector::FunctionSelector,\\n    address::{\\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\\n    },\\n    constants::{\\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\\n        MAX_FIELD_VALUE,\\n    },\\n    contract_class_id::ContractClassId,\\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\\n    merkle_tree::membership::MembershipWitness,\\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\\n};\\n\\n// We do below because `use crate::point::Point;` does not work\\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\\n\\nuse crate::public_keys::AddressPoint;\\nuse ec::{pow, sqrt};\\nuse std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key};\\n\\n// Aztec address\\npub struct AztecAddress {\\n    pub inner: Field,\\n}\\n\\nimpl Eq for AztecAddress {\\n    fn eq(self, other: Self) -> bool {\\n        self.to_field() == other.to_field()\\n    }\\n}\\n\\nimpl Empty for AztecAddress {\\n    fn empty() -> Self {\\n        Self { inner: 0 }\\n    }\\n}\\n\\nimpl ToField for AztecAddress {\\n    fn to_field(self) -> Field {\\n        self.inner\\n    }\\n}\\n\\nimpl FromField for AztecAddress {\\n    fn from_field(value: Field) -> AztecAddress {\\n        AztecAddress { inner: value }\\n    }\\n}\\n\\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\\n        [self.to_field()]\\n    }\\n}\\n\\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\\n        FromField::from_field(fields[0])\\n    }\\n}\\n\\nimpl AztecAddress {\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n\\n    pub fn to_address_point(self) -> AddressPoint {\\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\\n        // equation which defines our bn curve:\\n        // y^2 = x^3 - 17; x = address\\n        let x = self.inner;\\n        let y_squared = pow(x, 3) - 17;\\n\\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\\n        let mut y = sqrt(y_squared);\\n\\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\\n        // note: The field modulus is MAX_FIELD_VALUE + 1\\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\\n            y = (MAX_FIELD_VALUE + 1) - y;\\n        }\\n\\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\\n    }\\n\\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\\n        let public_keys_hash = public_keys.hash();\\n\\n        let pre_address = poseidon2_hash_with_separator(\\n            [public_keys_hash.to_field(), partial_address.to_field()],\\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\\n        );\\n\\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\\n            public_keys.ivpk_m.to_point(),\\n        );\\n\\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\\n        AztecAddress::from_field(address_point.x)\\n    }\\n\\n    pub fn compute_from_private_function(\\n        function_selector: FunctionSelector,\\n        function_vk_hash: Field,\\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\\n        contract_class_artifact_hash: Field,\\n        contract_class_public_bytecode_commitment: Field,\\n        salted_initialization_hash: SaltedInitializationHash,\\n        public_keys: PublicKeys,\\n    ) -> Self {\\n        let private_functions_root = private_functions_root_from_siblings(\\n            function_selector,\\n            function_vk_hash,\\n            function_leaf_membership_witness.leaf_index,\\n            function_leaf_membership_witness.sibling_path,\\n        );\\n\\n        let contract_class_id = ContractClassId::compute(\\n            contract_class_artifact_hash,\\n            private_functions_root,\\n            contract_class_public_bytecode_commitment,\\n        );\\n\\n        // Compute contract address using the preimage which includes the class_id.\\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\\n            contract_class_id,\\n            salted_initialization_hash,\\n        );\\n\\n        AztecAddress::compute(public_keys, partial_address)\\n    }\\n\\n    pub fn is_zero(self) -> bool {\\n        self.inner == 0\\n    }\\n\\n    pub fn assert_is_zero(self) {\\n        assert(self.to_field() == 0);\\n    }\\n}\\n\\n#[test]\\nfn compute_address_from_partial_and_pub_keys() {\\n    let public_keys = PublicKeys {\\n        npk_m: NpkM {\\n            inner: Point {\\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\\n                is_infinite: false,\\n            },\\n        },\\n        ivpk_m: IvpkM {\\n            inner: Point {\\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\\n                is_infinite: false,\\n            },\\n        },\\n        ovpk_m: OvpkM {\\n            inner: Point {\\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\\n                is_infinite: false,\\n            },\\n        },\\n        tpk_m: TpkM {\\n            inner: Point {\\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\\n                is_infinite: false,\\n            },\\n        },\\n    };\\n\\n    let partial_address = PartialAddress::from_field(\\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\\n    );\\n\\n    let address = AztecAddress::compute(public_keys, partial_address);\\n\\n    // The following value was generated by `derivation.test.ts`.\\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\\n    let expected_computed_address_from_partial_and_pubkeys =\\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\\n}\\n\\n#[test]\\nfn compute_preaddress_from_partial_and_pub_keys() {\\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\\n    let expected_computed_preaddress_from_partial_and_pubkey =\\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\\n}\\n\\n#[test]\\nfn from_field_to_field() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(FromField::from_field(address.to_field()), address);\\n}\\n\\n#[test]\\nfn serde() {\\n    let address = AztecAddress { inner: 37 };\\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\\n}\\n"},"261":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\\n\\npub struct KeyValidationRequest {\\n    pub pk_m: Point,\\n    pub sk_app: Field, // not a grumpkin scalar because it\'s output of poseidon2\\n}\\n\\nimpl Eq for KeyValidationRequest {\\n    fn eq(self, request: KeyValidationRequest) -> bool {\\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\\n    }\\n}\\n\\nimpl Empty for KeyValidationRequest {\\n    fn empty() -> Self {\\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\\n    }\\n}\\n\\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\\n    }\\n}\\n\\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\\n        Self {\\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\\n            sk_app: fields[3],\\n        }\\n    }\\n}\\n"},"304":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\\n\\npub struct FunctionSelector {\\n    // 1st 4-bytes of abi-encoding of function.\\n    pub inner: u32,\\n}\\n\\nimpl Eq for FunctionSelector {\\n    fn eq(self, function_selector: FunctionSelector) -> bool {\\n        function_selector.inner == self.inner\\n    }\\n}\\n\\nimpl Serialize<1> for FunctionSelector {\\n    fn serialize(self: Self) -> [Field; 1] {\\n        [self.inner as Field]\\n    }\\n}\\n\\nimpl Deserialize<1> for FunctionSelector {\\n    fn deserialize(fields: [Field; 1]) -> Self {\\n        Self { inner: fields[0] as u32 }\\n    }\\n}\\n\\nimpl FromField for FunctionSelector {\\n    fn from_field(field: Field) -> Self {\\n        Self { inner: field as u32 }\\n    }\\n}\\n\\nimpl ToField for FunctionSelector {\\n    fn to_field(self) -> Field {\\n        self.inner as Field\\n    }\\n}\\n\\nimpl Empty for FunctionSelector {\\n    fn empty() -> Self {\\n        Self { inner: 0 as u32 }\\n    }\\n}\\n\\nimpl FunctionSelector {\\n    pub fn from_u32(value: u32) -> Self {\\n        Self { inner: value }\\n    }\\n\\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\\n        let bytes = signature.as_bytes();\\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\\n\\n        // `hash` is automatically truncated to fit within 32 bits.\\n        FunctionSelector::from_field(hash)\\n    }\\n\\n    pub fn zero() -> Self {\\n        Self { inner: 0 }\\n    }\\n}\\n\\n#[test]\\nfn test_is_valid_selector() {\\n    let selector = FunctionSelector::from_signature(\\"IS_VALID()\\");\\n    assert_eq(selector.to_field(), 0x73cdda47);\\n}\\n\\n#[test]\\nfn test_long_selector() {\\n    let selector =\\n        FunctionSelector::from_signature(\\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\\");\\n    assert_eq(selector.to_field(), 0x7590a997);\\n}\\n"},"315":{"path":"/home/john-play/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.68.2/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\\n    address::public_keys_hash::PublicKeysHash,\\n    constants::{\\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\\n    },\\n    hash::poseidon2_hash_with_separator,\\n    point::POINT_LENGTH,\\n    traits::{Deserialize, Hash, Serialize},\\n};\\n\\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\\nuse std::default::Default;\\n\\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\\n\\npub struct PublicKeys {\\n    pub npk_m: NpkM,\\n    pub ivpk_m: IvpkM,\\n    pub ovpk_m: OvpkM,\\n    pub tpk_m: TpkM,\\n}\\n\\npub trait ToPoint {\\n    fn to_point(self) -> Point;\\n}\\n\\npub struct NpkM {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for NpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for NpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\\nimpl Hash for NpkM {\\n    fn hash(self) -> Field {\\n        self.inner.hash()\\n    }\\n}\\n\\npub struct IvpkM {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for IvpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for IvpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\npub struct OvpkM {\\n    pub inner: Point,\\n}\\n\\nimpl Hash for OvpkM {\\n    fn hash(self) -> Field {\\n        self.inner.hash()\\n    }\\n}\\n\\nimpl ToPoint for OvpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for OvpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\npub struct TpkM {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for TpkM {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\nimpl Serialize<POINT_LENGTH> for TpkM {\\n    fn serialize(self) -> [Field; POINT_LENGTH] {\\n        self.inner.serialize()\\n    }\\n}\\n\\nimpl Default for PublicKeys {\\n    fn default() -> Self {\\n        PublicKeys {\\n            npk_m: NpkM {\\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\\n            },\\n            ivpk_m: IvpkM {\\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\\n            },\\n            ovpk_m: OvpkM {\\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\\n            },\\n            tpk_m: TpkM {\\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\\n            },\\n        }\\n    }\\n}\\n\\nimpl Eq for PublicKeys {\\n    fn eq(self, other: PublicKeys) -> bool {\\n        (self.npk_m.inner == other.npk_m.inner)\\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\\n            & (self.tpk_m.inner == other.tpk_m.inner)\\n    }\\n}\\n\\nimpl PublicKeys {\\n    pub fn hash(self) -> PublicKeysHash {\\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\\n            self.serialize(),\\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\\n        ))\\n    }\\n}\\n\\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\\n        [\\n            self.npk_m.inner.x,\\n            self.npk_m.inner.y,\\n            self.npk_m.inner.is_infinite as Field,\\n            self.ivpk_m.inner.x,\\n            self.ivpk_m.inner.y,\\n            self.ivpk_m.inner.is_infinite as Field,\\n            self.ovpk_m.inner.x,\\n            self.ovpk_m.inner.y,\\n            self.ovpk_m.inner.is_infinite as Field,\\n            self.tpk_m.inner.x,\\n            self.tpk_m.inner.y,\\n            self.tpk_m.inner.is_infinite as Field,\\n        ]\\n    }\\n}\\n\\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\\n        PublicKeys {\\n            npk_m: NpkM {\\n                inner: Point {\\n                    x: serialized[0],\\n                    y: serialized[1],\\n                    is_infinite: serialized[2] as bool,\\n                },\\n            },\\n            ivpk_m: IvpkM {\\n                inner: Point {\\n                    x: serialized[3],\\n                    y: serialized[4],\\n                    is_infinite: serialized[5] as bool,\\n                },\\n            },\\n            ovpk_m: OvpkM {\\n                inner: Point {\\n                    x: serialized[6],\\n                    y: serialized[7],\\n                    is_infinite: serialized[8] as bool,\\n                },\\n            },\\n            tpk_m: TpkM {\\n                inner: Point {\\n                    x: serialized[9],\\n                    y: serialized[10],\\n                    is_infinite: serialized[11] as bool,\\n                },\\n            },\\n        }\\n    }\\n}\\n\\npub struct AddressPoint {\\n    pub inner: Point,\\n}\\n\\nimpl ToPoint for AddressPoint {\\n    fn to_point(self) -> Point {\\n        self.inner\\n    }\\n}\\n\\n#[test]\\nunconstrained fn compute_public_keys_hash() {\\n    let keys = PublicKeys {\\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\\n    };\\n\\n    let actual = keys.hash();\\n    let expected_public_keys_hash =\\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\\n\\n    assert(actual.to_field() == expected_public_keys_hash);\\n}\\n\\n#[test]\\nunconstrained fn compute_default_hash() {\\n    let keys = PublicKeys::default();\\n\\n    let actual = keys.hash();\\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\\n\\n    assert(actual.to_field() == test_data_default_hash);\\n}\\n\\n#[test]\\nunconstrained fn test_public_keys_serialization() {\\n    let keys = PublicKeys {\\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\\n    };\\n\\n    let serialized = keys.serialize();\\n    let deserialized = PublicKeys::deserialize(serialized);\\n\\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\\n}\\n"}}}');

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@swc","vendor-chunks/antd","vendor-chunks/@babel","vendor-chunks/react-icons"], () => (__webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES&page=%2FRockPaperScissors&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2FRockPaperScissors.tsx&absoluteAppPath=private-next-pages%2F_app&absoluteDocumentPath=private-next-pages%2F_document&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();